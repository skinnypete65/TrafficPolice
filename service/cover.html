
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>web: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">TrafficPolice/cmd/web/main.go (0.0%)</option>
				
				<option value="file1">TrafficPolice/docs/docs.go (0.0%)</option>
				
				<option value="file2">TrafficPolice/internal/app/app.go (0.0%)</option>
				
				<option value="file3">TrafficPolice/internal/app/converters.go (0.0%)</option>
				
				<option value="file4">TrafficPolice/internal/app/handlers.go (0.0%)</option>
				
				<option value="file5">TrafficPolice/internal/app/repos.go (0.0%)</option>
				
				<option value="file6">TrafficPolice/internal/app/servemux.go (0.0%)</option>
				
				<option value="file7">TrafficPolice/internal/app/services.go (0.0%)</option>
				
				<option value="file8">TrafficPolice/internal/camera/parser.go (0.0%)</option>
				
				<option value="file9">TrafficPolice/internal/config/config.go (0.0%)</option>
				
				<option value="file10">TrafficPolice/internal/converter/analytics.go (0.0%)</option>
				
				<option value="file11">TrafficPolice/internal/converter/auth.go (0.0%)</option>
				
				<option value="file12">TrafficPolice/internal/converter/camera.go (0.0%)</option>
				
				<option value="file13">TrafficPolice/internal/converter/case.go (0.0%)</option>
				
				<option value="file14">TrafficPolice/internal/converter/casedecision.go (0.0%)</option>
				
				<option value="file15">TrafficPolice/internal/converter/pagination.go (0.0%)</option>
				
				<option value="file16">TrafficPolice/internal/converter/rating.go (0.0%)</option>
				
				<option value="file17">TrafficPolice/internal/converter/solvedcases.go (0.0%)</option>
				
				<option value="file18">TrafficPolice/internal/converter/userinfo.go (0.0%)</option>
				
				<option value="file19">TrafficPolice/internal/domain/date.go (0.0%)</option>
				
				<option value="file20">TrafficPolice/internal/repository/mocks/AuthRepo.go (75.3%)</option>
				
				<option value="file21">TrafficPolice/internal/repository/mocks/CaseRepo.go (23.8%)</option>
				
				<option value="file22">TrafficPolice/internal/repository/mocks/PaginationRepo.go (78.9%)</option>
				
				<option value="file23">TrafficPolice/internal/repository/mocks/RatingRepo.go (13.4%)</option>
				
				<option value="file24">TrafficPolice/internal/repository/mocks/TransportRepo.go (78.9%)</option>
				
				<option value="file25">TrafficPolice/internal/repository/postresql/auth.go (0.0%)</option>
				
				<option value="file26">TrafficPolice/internal/repository/postresql/camera.go (0.0%)</option>
				
				<option value="file27">TrafficPolice/internal/repository/postresql/case.go (0.0%)</option>
				
				<option value="file28">TrafficPolice/internal/repository/postresql/checker.go (0.0%)</option>
				
				<option value="file29">TrafficPolice/internal/repository/postresql/contactinfo.go (0.0%)</option>
				
				<option value="file30">TrafficPolice/internal/repository/postresql/director.go (0.0%)</option>
				
				<option value="file31">TrafficPolice/internal/repository/postresql/expert.go (0.0%)</option>
				
				<option value="file32">TrafficPolice/internal/repository/postresql/pagination.go (0.0%)</option>
				
				<option value="file33">TrafficPolice/internal/repository/postresql/rating.go (0.0%)</option>
				
				<option value="file34">TrafficPolice/internal/repository/postresql/training.go (0.0%)</option>
				
				<option value="file35">TrafficPolice/internal/repository/postresql/transport.go (0.0%)</option>
				
				<option value="file36">TrafficPolice/internal/repository/postresql/violation.go (0.0%)</option>
				
				<option value="file37">TrafficPolice/internal/service/auth.go (81.5%)</option>
				
				<option value="file38">TrafficPolice/internal/service/camera.go (0.0%)</option>
				
				<option value="file39">TrafficPolice/internal/service/case.go (100.0%)</option>
				
				<option value="file40">TrafficPolice/internal/service/contactinfo.go (0.0%)</option>
				
				<option value="file41">TrafficPolice/internal/service/director.go (0.0%)</option>
				
				<option value="file42">TrafficPolice/internal/service/expert.go (0.0%)</option>
				
				<option value="file43">TrafficPolice/internal/service/img.go (0.0%)</option>
				
				<option value="file44">TrafficPolice/internal/service/pagination.go (100.0%)</option>
				
				<option value="file45">TrafficPolice/internal/service/rating.go (0.0%)</option>
				
				<option value="file46">TrafficPolice/internal/service/training.go (0.0%)</option>
				
				<option value="file47">TrafficPolice/internal/service/violation.go (0.0%)</option>
				
				<option value="file48">TrafficPolice/internal/tokens/manager.go (29.2%)</option>
				
				<option value="file49">TrafficPolice/internal/transport/rabbitmq/connection.go (0.0%)</option>
				
				<option value="file50">TrafficPolice/internal/transport/rabbitmq/finepublisher.go (0.0%)</option>
				
				<option value="file51">TrafficPolice/internal/transport/rest/auth.go (0.0%)</option>
				
				<option value="file52">TrafficPolice/internal/transport/rest/camera.go (0.0%)</option>
				
				<option value="file53">TrafficPolice/internal/transport/rest/case.go (0.0%)</option>
				
				<option value="file54">TrafficPolice/internal/transport/rest/contactinfo.go (0.0%)</option>
				
				<option value="file55">TrafficPolice/internal/transport/rest/director.go (0.0%)</option>
				
				<option value="file56">TrafficPolice/internal/transport/rest/expert.go (0.0%)</option>
				
				<option value="file57">TrafficPolice/internal/transport/rest/middlewares/auth.go (0.0%)</option>
				
				<option value="file58">TrafficPolice/internal/transport/rest/parseimg.go (0.0%)</option>
				
				<option value="file59">TrafficPolice/internal/transport/rest/rating.go (0.0%)</option>
				
				<option value="file60">TrafficPolice/internal/transport/rest/response/response.go (0.0%)</option>
				
				<option value="file61">TrafficPolice/internal/transport/rest/training.go (0.0%)</option>
				
				<option value="file62">TrafficPolice/internal/transport/rest/violation.go (0.0%)</option>
				
				<option value="file63">TrafficPolice/internal/validation/date.go (0.0%)</option>
				
				<option value="file64">TrafficPolice/pkg/hash/hash.go (80.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        _ "TrafficPolice/docs"
        "TrafficPolice/internal/app"
)

// @title Traffic Police API
// @version 1.0
// @description API Server for Traffic Police Application

// @host localhost:8080
// @BasePath /

// @securityDefinitions.apikey ApiKeyAuth
// @in header
// @name Authorization
func main() <span class="cov0" title="0">{
        app.Run()
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/auth/confirm/expert": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Подтверждение эксперта по id. Может делать только директор",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Подтверждение эксперта",
                "operationId": "auth-confirm-expert",
                "parameters": [
                    {
                        "description": "id эксперта и информация о подтверждении",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ConfirmExpertInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.SignInOutput"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/auth/sign_in": {
            "post": {
                "description": "Вход для всех пользователей по логину и паролю",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Вход пользователей",
                "operationId": "auth-sign-in",
                "parameters": [
                    {
                        "description": "Логин и пароль",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.SignInInput"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.SignInOutput"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/auth/sign_up": {
            "post": {
                "description": "Регистрация эксперта по логину и паролю",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "auth"
                ],
                "summary": "Регистрация эксперта",
                "operationId": "auth-sign-up",
                "parameters": [
                    {
                        "description": "Логин и пароль",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.SignUp"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/camera": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Зарегистрировать камеру может только директор. Возвращает id камеры",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "camera"
                ],
                "summary": "Регистрация камеры",
                "operationId": "create-camera",
                "parameters": [
                    {
                        "description": "Информация о камере",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.RegisterCamera"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.IDResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/camera/type": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Зарегистрировать новый вид камеры может только директор. Возвращает id вида камеры",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "camera"
                ],
                "summary": "Регистрация вида камеры",
                "operationId": "create-camera-type",
                "parameters": [
                    {
                        "description": "Информация о виде камеры",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.CameraTypeIn"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.IDResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/case": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Принимает бинарную строку в описанном формате. Добавить проишествие может только камера",
                "consumes": [
                    "application/octet-stream"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "case"
                ],
                "summary": "Добавление информации о проишествии",
                "operationId": "case-add",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.IDResponse"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/case/{id}/img": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Получение фотографии проишествия по id прошествия. Воспользоваться могут эксперт или директор",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "case"
                ],
                "summary": "Получение фотографии проишествия",
                "operationId": "case-image-get",
                "parameters": [
                    {
                        "type": "string",
                        "description": "id камеры",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "file"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Принимает фотографию и сохраняет ее по переданному id. Добавить фотографию может только камера",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "case"
                ],
                "summary": "Добавление фотографии к проишествию",
                "operationId": "case-image-upload",
                "parameters": [
                    {
                        "type": "string",
                        "description": "id камеры",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "file",
                        "description": "Фотография проишествия",
                        "name": "file",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/contact_info": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Принимает excel файл в формате по столбикам: Буквы авто:Номера авто:Регион:Номер телефона:email:VK ID: Tg ID. Только директор может загрузить файл",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "contact_info"
                ],
                "summary": "Ввод информации о транспорте и его владельце",
                "operationId": "insert-contact-info",
                "parameters": [
                    {
                        "type": "file",
                        "description": "Excel файл с контактной информацией",
                        "name": "file",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/director/analytics/expert": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Получить количество всех случаев, правильно решенных случае, неправильно решенных случаев,",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "director"
                ],
                "summary": "Получение аналитики проверяющих специалистов по промежуткам времени",
                "operationId": "director-analytics-expert",
                "parameters": [
                    {
                        "type": "integer",
                        "description": "id эксперта",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Начало промежутка времени в формате yyyy-mm-dd",
                        "name": "start_time",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "string",
                        "description": "Конец промежутка времени в формате yyyy-mm-dd",
                        "name": "end_time",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dto.AnalyticsInterval"
                            }
                        }
                    },
                    "204": {
                        "description": ""
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/director/cases": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Получение состояния случаев. Воспользоваться может только директор",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "director"
                ],
                "summary": "Получение состояния случаев",
                "operationId": "director-cases-get",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dto.CaseStatus"
                            }
                        }
                    },
                    "204": {
                        "description": ""
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/expert/decision": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Установка оценки случая экспертом. Воспользоваться может только эксперт",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "expert"
                ],
                "summary": "Оценка случая экспертом",
                "operationId": "expert-set-decision",
                "parameters": [
                    {
                        "description": "id случая и решение эксперта",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.Decision"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "file"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/expert/get_case": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Получение случая для оценки экспертом. Воспользоваться могут эксперт или директор",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "expert"
                ],
                "summary": "Получение случая для оценки экспертом",
                "operationId": "expert-get-case",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "file"
                        }
                    },
                    "204": {
                        "description": ""
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/expert/training": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Получение прошествий для тренировки. Может воспользоваться только эксперт",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "expert"
                ],
                "summary": "Получение проишествий для тренировки",
                "operationId": "expert-training",
                "parameters": [
                    {
                        "description": "Информация для фильтров по проишествиям",
                        "name": "input",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.SolvedCasesParams"
                        }
                    },
                    {
                        "type": "integer",
                        "description": "номер страницы",
                        "name": "page",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "integer",
                        "description": "Лимит кейсов на странице",
                        "name": "limit",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.TrainingInfo"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/expert/{id}/img": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Получение фотографии эксперта по его id. Воспользоваться могут эксперт или директор",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "expert"
                ],
                "summary": "Получение фотографии эксперта",
                "operationId": "expert-image-get",
                "parameters": [
                    {
                        "type": "string",
                        "description": "id эксперта",
                        "name": "id",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "file"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Добавление фотографии к профилю эксперта. Может воспользоваться директор или эксперт",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "expert"
                ],
                "summary": "Добавление фотографии к профилю эксперта",
                "operationId": "expert-image-upload",
                "parameters": [
                    {
                        "type": "string",
                        "description": "id эксперта",
                        "name": "id",
                        "in": "query",
                        "required": true
                    },
                    {
                        "type": "file",
                        "description": "Фотография эксперта",
                        "name": "file",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/rating": {
            "get": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Получение рейтинга экспертов. Воспользоваться могут эксперт или директор",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "rating"
                ],
                "summary": "Получение рейтинга экспертов",
                "operationId": "rating-get",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dto.RatingInfo"
                            }
                        }
                    },
                    "204": {
                        "description": ""
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        },
        "/violations": {
            "post": {
                "security": [
                    {
                        "ApiKeyAuth": []
                    }
                ],
                "description": "Принимает excel файл в формате по столбикам: Название правонарушения:Размер штрафа. Только директор может загрузить файл",
                "consumes": [
                    "multipart/form-data"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "violation"
                ],
                "summary": "Ввод информации о правонарушениях",
                "operationId": "insert-violations",
                "parameters": [
                    {
                        "type": "file",
                        "description": "Excel файл с информацией о правонарушениях",
                        "name": "file",
                        "in": "formData",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    },
                    "default": {
                        "description": "",
                        "schema": {
                            "$ref": "#/definitions/response.Body"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "dto.AnalyticsInterval": {
            "type": "object",
            "properties": {
                "all_cases_cnt": {
                    "type": "integer"
                },
                "correct_cnt": {
                    "type": "integer"
                },
                "date": {
                    "type": "string"
                },
                "incorrect_cnt": {
                    "type": "integer"
                },
                "max_consecutive_solved": {
                    "type": "integer"
                },
                "unknown_cnt": {
                    "type": "integer"
                }
            }
        },
        "dto.Camera": {
            "type": "object",
            "required": [
                "camera_type_id",
                "latitude",
                "longitude",
                "short_desc"
            ],
            "properties": {
                "camera_id": {
                    "type": "string"
                },
                "camera_type_id": {
                    "type": "string"
                },
                "latitude": {
                    "type": "number"
                },
                "longitude": {
                    "type": "number"
                },
                "short_desc": {
                    "type": "string"
                }
            }
        },
        "dto.CameraIn": {
            "type": "object",
            "required": [
                "camera_type_id",
                "latitude",
                "longitude",
                "short_desc"
            ],
            "properties": {
                "camera_type_id": {
                    "type": "string"
                },
                "latitude": {
                    "type": "number"
                },
                "longitude": {
                    "type": "number"
                },
                "short_desc": {
                    "type": "string"
                }
            }
        },
        "dto.CameraTypeIn": {
            "type": "object",
            "required": [
                "camera_name"
            ],
            "properties": {
                "camera_name": {
                    "type": "string"
                }
            }
        },
        "dto.Case": {
            "type": "object",
            "properties": {
                "camera": {
                    "$ref": "#/definitions/dto.Camera"
                },
                "date": {
                    "type": "string"
                },
                "fine_decision": {
                    "type": "boolean"
                },
                "id": {
                    "type": "string"
                },
                "is_solved": {
                    "type": "boolean"
                },
                "required_skill": {
                    "type": "integer"
                },
                "transport": {
                    "$ref": "#/definitions/dto.Transport"
                },
                "violation": {
                    "$ref": "#/definitions/dto.Violation"
                },
                "violation_value": {
                    "type": "string"
                }
            }
        },
        "dto.CaseAssessment": {
            "type": "object",
            "properties": {
                "expert_id": {
                    "type": "string"
                },
                "fine_decision": {
                    "type": "boolean"
                },
                "is_expert_solve": {
                    "type": "boolean"
                }
            }
        },
        "dto.CaseStatus": {
            "type": "object",
            "properties": {
                "case_assessments": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dto.CaseAssessment"
                    }
                },
                "case_date": {
                    "type": "string"
                },
                "case_id": {
                    "type": "string"
                },
                "fine_decision": {
                    "type": "boolean"
                },
                "is_solved": {
                    "type": "boolean"
                },
                "required_skill": {
                    "type": "integer"
                },
                "violation_value": {
                    "type": "string"
                }
            }
        },
        "dto.ConfirmExpertInput": {
            "type": "object",
            "required": [
                "expert_id"
            ],
            "properties": {
                "expert_id": {
                    "type": "string"
                },
                "is_confirmed": {
                    "type": "boolean"
                }
            }
        },
        "dto.Decision": {
            "type": "object",
            "properties": {
                "case_id": {
                    "type": "string"
                },
                "fine_decision": {
                    "type": "boolean"
                }
            }
        },
        "dto.Pagination": {
            "type": "object",
            "properties": {
                "current_page": {
                    "type": "integer"
                },
                "next": {
                    "type": "integer"
                },
                "previous": {
                    "type": "integer"
                },
                "record_per_page": {
                    "type": "integer"
                },
                "total_page": {
                    "type": "integer"
                }
            }
        },
        "dto.Person": {
            "type": "object",
            "properties": {
                "ID": {
                    "type": "string"
                },
                "email": {
                    "type": "string"
                },
                "phone_num": {
                    "type": "string"
                },
                "tg_id": {
                    "type": "string"
                },
                "vk_id": {
                    "type": "string"
                }
            }
        },
        "dto.RatingInfo": {
            "type": "object",
            "properties": {
                "competence_skill": {
                    "type": "integer"
                },
                "correct_cnt": {
                    "type": "integer"
                },
                "expert_id": {
                    "type": "string"
                },
                "incorrect_cnt": {
                    "type": "integer"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "dto.RegisterCamera": {
            "type": "object",
            "required": [
                "camera",
                "sign_up"
            ],
            "properties": {
                "camera": {
                    "$ref": "#/definitions/dto.CameraIn"
                },
                "sign_up": {
                    "$ref": "#/definitions/dto.SignUp"
                }
            }
        },
        "dto.SignInInput": {
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "properties": {
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "dto.SignInOutput": {
            "type": "object",
            "properties": {
                "accessToken": {
                    "type": "string"
                },
                "refresh_token": {
                    "type": "string"
                }
            }
        },
        "dto.SignUp": {
            "type": "object",
            "required": [
                "password",
                "username"
            ],
            "properties": {
                "password": {
                    "type": "string"
                },
                "username": {
                    "type": "string"
                }
            }
        },
        "dto.SolvedCasesParams": {
            "type": "object",
            "required": [
                "camera_id",
                "end_time",
                "required_skill",
                "start_time",
                "violation_id"
            ],
            "properties": {
                "camera_id": {
                    "type": "string"
                },
                "end_time": {
                    "type": "string"
                },
                "required_skill": {
                    "type": "integer"
                },
                "start_time": {
                    "type": "string"
                },
                "violation_id": {
                    "type": "string"
                }
            }
        },
        "dto.TrainingInfo": {
            "type": "object",
            "properties": {
                "cases": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dto.Case"
                    }
                },
                "pagination": {
                    "$ref": "#/definitions/dto.Pagination"
                }
            }
        },
        "dto.Transport": {
            "type": "object",
            "properties": {
                "chars": {
                    "type": "string"
                },
                "id": {
                    "type": "string"
                },
                "num": {
                    "type": "string"
                },
                "person": {
                    "$ref": "#/definitions/dto.Person"
                },
                "region": {
                    "type": "string"
                }
            }
        },
        "dto.Violation": {
            "type": "object",
            "properties": {
                "fine_amount": {
                    "type": "integer"
                },
                "id": {
                    "type": "string"
                },
                "name": {
                    "type": "string"
                }
            }
        },
        "response.Body": {
            "type": "object",
            "properties": {
                "message": {
                    "type": "string"
                }
            }
        },
        "response.IDResponse": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "string"
                }
            }
        }
    },
    "securityDefinitions": {
        "ApiKeyAuth": {
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "1.0",
        Host:             "localhost:8080",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "Traffic Police API",
        Description:      "API Server for Traffic Police Application",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package app

import (
        _ "TrafficPolice/docs"
        "TrafficPolice/internal/config"
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/tokens"
        "TrafficPolice/internal/transport/rabbitmq"
        "TrafficPolice/internal/transport/rest/middlewares"
        "TrafficPolice/internal/validation"
        "context"
        "errors"
        "fmt"
        "github.com/go-playground/validator/v10"
        "github.com/golang-migrate/migrate"
        _ "github.com/golang-migrate/migrate/database/postgres"
        _ "github.com/golang-migrate/migrate/source/file"
        "github.com/jackc/pgx/v5"
        amqp "github.com/rabbitmq/amqp091-go"
        "log"
        "net/http"
)

const (
        serviceConfigPath = "service_config.yaml"
        defaultMinExperts = 3
)

func Run() <span class="cov0" title="0">{
        cfg, err := config.ParseConfig(serviceConfigPath)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">if cfg.Rating.MinExperts &lt; defaultMinExperts </span><span class="cov0" title="0">{
                log.Fatalf("config min experts must be greater or equal %d, but got: %d",
                        defaultMinExperts, cfg.Rating.MinExperts,
                )
        }</span>

        // Init database
        <span class="cov0" title="0">dbConnString := setupDBConnString(cfg)
        dbConn, err := pgx.Connect(context.Background(), dbConnString)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer dbConn.Close(context.Background())

        runMigrations(dbConnString)

        // Init RabbitMQ
        mQConn, err := rabbitmq.NewRabbitMQConn(cfg)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">defer mQConn.Close()

        // Init handlers, service, repos (Clean architecture)
        tokenManager, err := tokens.NewTokenManager(cfg.SigningKey)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">finePublisher := setupFinePublisher(mQConn)
        validate := newValidate()

        converters := newConverters()
        repos := newRepos(dbConn)
        services := newServices(repos, tokenManager, cfg)
        handlers := newHandlers(services, converters, validate, finePublisher)

        authMiddleware := middlewares.NewAuthMiddleware(tokenManager, services.expert)
        serveMuxInit := newServeMuxInit(handlers, authMiddleware)
        mux := serveMuxInit.Init()

        // Run logic
        registerDirectors(cfg, services.auth)

        done := make(chan struct{})
        go services.rating.RunReportPeriod(done)

        // Run Server
        port := fmt.Sprintf(":%d", cfg.ServerPort)
        server := http.Server{
                Addr:    port,
                Handler: mux,
        }

        log.Printf("Run server on %s\n", port)
        err = server.ListenAndServe()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>

        <span class="cov0" title="0">done &lt;- struct{}{}</span>

}

func runMigrations(dbUrl string) <span class="cov0" title="0">{
        log.Printf("Run migrations on %s\n", dbUrl)
        m, err := migrate.New("file://migrations", dbUrl)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">err = m.Up()
        if errors.Is(err, migrate.ErrNoChange) </span><span class="cov0" title="0">{
                log.Println("Migrate no change")
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">log.Println("Migrate ran successfully")</span>
}

func registerDirectors(cfg *config.Config, authService service.AuthService) <span class="cov0" title="0">{
        users := make([]domain.UserInfo, len(cfg.Directors))

        for i, d := range cfg.Directors </span><span class="cov0" title="0">{
                users[i] = domain.UserInfo{Username: d.Username, Password: d.Password}
        }</span>

        <span class="cov0" title="0">err := authService.RegisterDirectors(users)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
}

func newValidate() *validator.Validate <span class="cov0" title="0">{
        validate := validator.New(validator.WithRequiredStructEnabled())
        err := validate.RegisterValidation("is_date_only", validation.IsDateOnly)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>

        <span class="cov0" title="0">return validate</span>
}

func setupDBConnString(cfg *config.Config) string <span class="cov0" title="0">{
        return fmt.Sprintf(
                "postgresql://%s:%s@%s:%d/%s?sslmode=disable",
                cfg.Postgres.User,
                cfg.Postgres.Password,
                cfg.Postgres.Host,
                cfg.Postgres.Port,
                cfg.Postgres.Database,
        )
}</span>

func setupFinePublisher(mqConn *amqp.Connection) *rabbitmq.FinePublisher <span class="cov0" title="0">{
        finePublisher, err := rabbitmq.NewFinePublisher(mqConn)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">err = finePublisher.SetupExchangeAndQueue(
                rabbitmq.ExchangeParams{
                        Name:       rabbitmq.FineExchange,
                        Kind:       rabbitmq.Fanout,
                        Durable:    true,
                        AutoDelete: false,
                        Internal:   false,
                        NoWait:     false,
                        Args:       nil,
                }, rabbitmq.QueueParams{
                        Name:       rabbitmq.FineQueue,
                        Durable:    false,
                        AutoDelete: false,
                        Exclusive:  false,
                        NoWait:     false,
                        Args:       nil,
                },
                rabbitmq.BindingParams{
                        Queue:    rabbitmq.FineQueue,
                        Key:      "",
                        Exchange: rabbitmq.FineExchange,
                        NoWait:   false,
                        Args:     nil,
                },
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return finePublisher</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package app

import "TrafficPolice/internal/converter"

type converters struct {
        auth          *converter.AuthConverter
        camera        *converter.CameraConverter
        caseConverter *converter.CaseConverter
        caseDecision  *converter.CaseDecisionConverter
        pagination    *converter.PaginationConverter
        solvedCases   *converter.SolvedCasesConverter
        userInfo      *converter.UserInfoConverter
        analytics     *converter.AnalyticsConverter
        rating        *converter.RatingConverter
}

func newConverters() *converters <span class="cov0" title="0">{
        return &amp;converters{
                auth:          converter.NewAuthConverter(),
                camera:        converter.NewCameraConverter(),
                caseConverter: converter.NewCaseConverter(),
                caseDecision:  converter.NewCaseDecisionConverter(),
                pagination:    converter.NewPaginationConverter(),
                solvedCases:   converter.NewSolvedCasesConverter(),
                userInfo:      converter.NewUserInfoConverter(),
                analytics:     converter.NewAnalyticsConverter(),
                rating:        converter.NewRatingConverter(),
        }
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package app

import (
        "TrafficPolice/internal/camera"
        "TrafficPolice/internal/transport/rabbitmq"
        "TrafficPolice/internal/transport/rest"
        "github.com/go-playground/validator/v10"
)

type handlers struct {
        rating      *rest.RatingHandler
        auth        *rest.AuthHandler
        camera      *rest.CameraHandler
        caseHandler *rest.CaseHandler
        contactInfo *rest.ContactInfoHandler
        violation   *rest.ViolationHandler
        expert      *rest.ExpertHandler
        training    *rest.TrainingHandler
        director    *rest.DirectorHandler
}

func newHandlers(
        s *services,
        c *converters,
        validate *validator.Validate,
        finePublisher *rabbitmq.FinePublisher,
) *handlers <span class="cov0" title="0">{
        cameraParser := camera.NewParser(s.camera)
        return &amp;handlers{
                rating:      rest.NewRatingHandler(s.rating, c.rating),
                auth:        rest.NewAuthHandler(s.auth, validate, c.userInfo, c.auth),
                camera:      rest.NewCameraHandler(s.camera, s.auth, validate, c.camera),
                caseHandler: rest.NewCaseHandler(s.caseService, s.img, s.camera, c.caseConverter, cameraParser),
                contactInfo: rest.NewContactInfoHandler(s.contactInfo),
                violation:   rest.NewViolationHandler(s.violation),
                expert: rest.NewExpertHandler(
                        s.img, s.expert, s.rating, finePublisher, c.caseConverter, c.caseDecision,
                ),
                training: rest.NewTrainingHandler(
                        s.training, s.pagination, validate, c.caseConverter, c.pagination, c.solvedCases,
                ),
                director: rest.NewDirectorHandler(s.director, c.caseConverter, c.analytics),
        }
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package app

import (
        "TrafficPolice/internal/repository"
        postgres "TrafficPolice/internal/repository/postresql"
        "github.com/jackc/pgx/v5"
)

type repos struct {
        rating      repository.RatingRepo
        auth        repository.AuthRepo
        pagination  repository.PaginationRepo
        camera      repository.CameraRepo
        transport   repository.TransportRepo
        caseRepo    repository.CaseRepo
        contactInfo repository.ContactInfoRepo
        violation   repository.ViolationRepo
        training    repository.TrainingRepo
        checker     repository.CheckerRepo
        expert      repository.ExpertRepo
        director    repository.DirectorRepo
}

func newRepos(dbConn *pgx.Conn) *repos <span class="cov0" title="0">{
        return &amp;repos{
                rating:      postgres.NewRatingRepoPostgres(dbConn),
                auth:        postgres.NewAuthRepoPostgres(dbConn),
                pagination:  postgres.NewPaginationRepoPostgres(dbConn),
                camera:      postgres.NewCameraRepoPostgres(dbConn),
                transport:   postgres.NewTransportRepoPostgres(dbConn),
                caseRepo:    postgres.NewCaseRepoPostgres(dbConn),
                contactInfo: postgres.NewContactInfoRepoPostgres(dbConn),
                violation:   postgres.NewViolationDBPostgres(dbConn),
                training:    postgres.NewTrainingRepoPostgres(dbConn),
                checker:     postgres.NewCheckerRepoPostgres(dbConn),
                expert:      postgres.NewExpertRepoPostgres(dbConn),
                director:    postgres.NewDirectorRepoPostgres(dbConn),
        }
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package app

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/transport/rest/middlewares"
        httpSwagger "github.com/swaggo/http-swagger"
        "net/http"
)

type ServeMuxInit struct {
        h              *handlers
        authMiddleware *middlewares.AuthMiddleware
        mux            *http.ServeMux
}

func newServeMuxInit(h *handlers, authMiddleware *middlewares.AuthMiddleware) *ServeMuxInit <span class="cov0" title="0">{
        return &amp;ServeMuxInit{
                h:              h,
                authMiddleware: authMiddleware,
                mux:            http.NewServeMux(),
        }
}</span>

func (s *ServeMuxInit) Init() *http.ServeMux <span class="cov0" title="0">{
        // Setup Routes
        s.mux.HandleFunc("/docs/", httpSwagger.WrapHandler)

        s.initCameraHandlers()
        s.initCaseHandlers()
        s.initContactInfoHandlers()
        s.initViolationHandlers()
        s.initAuthHandlers()
        s.initExpertHandlers()
        s.initRatingHandlers()
        s.initDirectorHandlers()

        return s.mux
}</span>

func (s *ServeMuxInit) initCameraHandlers() <span class="cov0" title="0">{
        // Camera handlers
        s.mux.Handle("POST /camera/type",
                s.authMiddleware.IdentifyRole(http.HandlerFunc(s.h.camera.AddCameraType), domain.DirectorRole),
        )
        s.mux.Handle("POST /camera",
                s.authMiddleware.IdentifyRole(http.HandlerFunc(s.h.camera.RegisterCamera), domain.DirectorRole),
        )
}</span>
func (s *ServeMuxInit) initCaseHandlers() <span class="cov0" title="0">{
        // Case handlers
        s.mux.Handle("POST /case",
                s.authMiddleware.IdentifyRole(http.HandlerFunc(s.h.caseHandler.AddCase), domain.CameraRole),
        )
        s.mux.Handle("POST /case/{id}/img",
                s.authMiddleware.IdentifyRole(http.HandlerFunc(s.h.caseHandler.UploadCaseImg), domain.CameraRole),
        )
        s.mux.Handle("GET /case/{id}/img",
                s.authMiddleware.IdentifyRole(
                        s.authMiddleware.IsExpertConfirmed(http.HandlerFunc(s.h.caseHandler.GetCaseImg)),
                        domain.DirectorRole, domain.ExpertRole,
                ),
        )
}</span>

func (s *ServeMuxInit) initContactInfoHandlers() <span class="cov0" title="0">{
        // ContactInfo handlers
        s.mux.Handle("POST /contact_info",
                s.authMiddleware.IdentifyRole(http.HandlerFunc(s.h.contactInfo.InsertContactInfo), domain.DirectorRole),
        )
}</span>

func (s *ServeMuxInit) initViolationHandlers() <span class="cov0" title="0">{
        // Violations handlers
        s.mux.Handle("POST /violations",
                s.authMiddleware.IdentifyRole(http.HandlerFunc(s.h.violation.InsertViolations), domain.DirectorRole),
        )
}</span>

func (s *ServeMuxInit) initAuthHandlers() <span class="cov0" title="0">{
        // Auth handlers
        s.mux.HandleFunc("POST /auth/sign_up", s.h.auth.SignUp)
        s.mux.HandleFunc("POST /auth/sign_in", s.h.auth.SignIn)
        s.mux.Handle("POST /auth/confirm/expert",
                s.authMiddleware.IdentifyRole(http.HandlerFunc(s.h.auth.ConfirmExpert), domain.DirectorRole),
        )
}</span>

func (s *ServeMuxInit) initExpertHandlers() <span class="cov0" title="0">{
        // Expert handlers
        s.mux.Handle("POST /expert/{id}/img", s.authMiddleware.IdentifyRole(
                s.authMiddleware.IsExpertConfirmed(http.HandlerFunc(s.h.expert.UploadExpertImg)),
                domain.DirectorRole, domain.ExpertRole),
        )
        s.mux.Handle("GET /expert/{id}/img",
                s.authMiddleware.IdentifyRole(
                        s.authMiddleware.IsExpertConfirmed(
                                http.HandlerFunc(s.h.expert.GetExpertImg),
                        ),
                        domain.DirectorRole, domain.ExpertRole,
                ),
        )

        s.mux.Handle("GET /expert/get_case",
                s.authMiddleware.IdentifyRole(
                        s.authMiddleware.IsExpertConfirmed(
                                http.HandlerFunc(s.h.expert.GetCaseForExpert),
                        ),
                        domain.ExpertRole,
                ),
        )
        s.mux.Handle("POST /expert/decision",
                s.authMiddleware.IdentifyRole(
                        s.authMiddleware.IsExpertConfirmed(
                                http.HandlerFunc(s.h.expert.SetCaseDecision),
                        ),
                        domain.ExpertRole,
                ),
        )
        s.mux.Handle("POST /expert/training",
                s.authMiddleware.IdentifyRole(
                        s.authMiddleware.IsExpertConfirmed(
                                http.HandlerFunc(s.h.training.GetSolvedCasesByParams),
                        ),
                        domain.ExpertRole,
                ),
        )
}</span>

func (s *ServeMuxInit) initRatingHandlers() <span class="cov0" title="0">{
        // Rating Handlers
        s.mux.Handle("GET /rating",
                s.authMiddleware.IdentifyRole(
                        http.HandlerFunc(s.h.rating.GetRating),
                        domain.ExpertRole, domain.DirectorRole,
                ),
        )
}</span>

func (s *ServeMuxInit) initDirectorHandlers() <span class="cov0" title="0">{
        // Director Handlers
        s.mux.Handle("GET /director/cases",
                s.authMiddleware.IdentifyRole(
                        http.HandlerFunc(s.h.director.GetCases),
                        domain.DirectorRole,
                ),
        )
        s.mux.Handle("GET /director/analytics/expert",
                s.authMiddleware.IdentifyRole(
                        http.HandlerFunc(s.h.director.ExpertAnalytics),
                        domain.DirectorRole,
                ),
        )
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package app

import (
        "TrafficPolice/internal/config"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/tokens"
        "TrafficPolice/pkg/hash"
)

type services struct {
        img         service.ImgService
        rating      service.RatingService
        auth        service.AuthService
        pagination  service.PaginationService
        camera      service.CameraService
        caseService service.CaseService
        contactInfo service.ContactInfoService
        violation   service.ViolationService
        expert      service.ExpertService
        training    service.TrainingService
        director    service.DirectorService
}

func newServices(r *repos, manager tokens.TokenManager, cfg *config.Config) *services <span class="cov0" title="0">{
        hasher := hash.NewSHA1Hasher(cfg.PassSalt)

        return &amp;services{
                img:         service.NewImgService(),
                rating:      service.NewRatingService(r.rating, cfg.Rating),
                auth:        service.NewAuthService(r.auth, r.rating, hasher, manager),
                pagination:  service.NewPaginationService(r.pagination),
                camera:      service.NewCameraService(r.camera),
                caseService: service.NewCaseService(r.caseRepo, r.transport),
                contactInfo: service.NewContactInfoService(r.contactInfo),
                violation:   service.NewViolationService(r.violation),
                expert:      service.NewExpertService(r.expert, r.caseRepo, cfg.Consensus),
                training:    service.NewTrainingService(r.training),
                director:    service.NewDirectorService(r.director, r.checker),
        }
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package camera

import (
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/transport/rest/dto"
        "bytes"
        "encoding/binary"
        "fmt"
        "github.com/jcalabro/leb128"
        "log"
        "time"
)

const (
        typeCamerus1 = "camerus1"
        typeCamerus2 = "camerus2"
        typeCamerus3 = "camerus3"

        cameraIDKey = "camera_id"
        cameraKey   = "camera"
)

type Parser struct {
        cameraService service.CameraService
}

func NewParser(cameraService service.CameraService) *Parser <span class="cov0" title="0">{
        return &amp;Parser{
                cameraService: cameraService,
        }
}</span>

func (p *Parser) ParseCameraInfo(payload []byte) (dto.Case, error) <span class="cov0" title="0">{
        if len(payload) == 0 </span><span class="cov0" title="0">{
                return dto.Case{}, errs.ErrEmptyPayload
        }</span>

        <span class="cov0" title="0">payload = payload[2:]
        info := p.parsePayload(payload)

        var cameraType string
        var err error

        if cameraID, ok := info[cameraIDKey]; ok </span><span class="cov0" title="0">{
                cameraType, err = p.cameraService.GetCameraTypeByCameraID(cameraID.(string))
        }</span> else<span class="cov0" title="0"> if camera, ok := info[cameraKey].(map[string]any); ok </span><span class="cov0" title="0">{
                cameraID := camera["id"].(string)
                cameraType, err = p.cameraService.GetCameraTypeByCameraID(cameraID)
        }</span> else<span class="cov0" title="0"> {
                err = errs.ErrUnknownCameraID
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return dto.Case{}, err
        }</span>

        <span class="cov0" title="0">switch cameraType </span>{
        case typeCamerus1:<span class="cov0" title="0">
                return p.parseCamerus1(info)</span>
        case typeCamerus2:<span class="cov0" title="0">
                return p.parseCamerus2(info)</span>
        case typeCamerus3:<span class="cov0" title="0">
                return p.parseCamerus3(info)</span>
        default:<span class="cov0" title="0">
                return dto.Case{}, errs.ErrUnknownCameraType</span>
        }
}

func (p *Parser) parsePayload(payload []byte) map[string]any <span class="cov0" title="0">{
        info := make(map[string]any)

        for len(payload) &gt; 0 </span><span class="cov0" title="0">{
                keySize := binary.BigEndian.Uint16(payload[:2])
                payload = payload[2:]

                valueSize := binary.BigEndian.Uint16(payload[:2])
                payload = payload[2:]

                valueType := payload[0]
                payload = payload[1:]

                keyValue := payload[:keySize]
                payload = payload[keySize:]

                value := payload[:valueSize]
                payload = payload[valueSize:]

                log.Println(keySize, valueSize, valueType, keyValue, value)

                if valueType == 0 </span><span class="cov0" title="0">{
                        info[string(keyValue)] = string(value)
                }</span> else<span class="cov0" title="0"> if valueType == 1 </span><span class="cov0" title="0">{
                        n, _ := leb128.DecodeS64(bytes.NewBuffer(value))
                        info[string(keyValue)] = n
                }</span> else<span class="cov0" title="0"> if valueType == 2 </span><span class="cov0" title="0">{
                        dict := p.parsePayload(value)
                        info[string(keyValue)] = dict
                }</span>
        }

        <span class="cov0" title="0">return info</span>
}

func (p *Parser) parseCamerus1(info map[string]any) (dto.Case, error) <span class="cov0" title="0">{
        date, err := time.Parse(time.RFC3339, info["datetime"].(string))
        if err != nil </span><span class="cov0" title="0">{
                return dto.Case{}, err
        }</span>
        <span class="cov0" title="0">return dto.Case{
                Transport: dto.Transport{
                        Chars:  info["transport_chars"].(string),
                        Num:    info["transport_numbers"].(string),
                        Region: info["transport_region"].(string),
                },
                Camera: dto.Camera{
                        ID: info["camera_id"].(string),
                },
                Violation: dto.Violation{
                        ID: info["violation_id"].(string),
                },
                ViolationValue: info["violation_value"].(string),
                RequiredSkill:  info["skill_value"].(int64),
                Date:           date,
        }, nil</span>
}

func (p *Parser) parseCamerus2(info map[string]any) (dto.Case, error) <span class="cov0" title="0">{
        transport := info["transport"].(map[string]any)
        camera := info["camera"].(map[string]any)
        violation := info["violation"].(map[string]any)
        skill := info["skill"].(map[string]any)

        datetime := info["datetime"].(map[string]any)

        year := datetime["year"].(int64)
        month := datetime["month"].(int64)
        day := datetime["day"].(int64)
        hour := datetime["hour"].(int64)
        minute := datetime["minute"].(int64)
        seconds := datetime["seconds"].(int64)
        utcOffset := datetime["utc_offset"].(string)

        dateString := fmt.Sprintf("%04d-%02d-%02dT%02d:%02d:%02d%s", year, month, day, hour, minute, seconds, utcOffset)
        date, err := time.Parse(time.RFC3339, dateString)
        if err != nil </span><span class="cov0" title="0">{
                return dto.Case{}, err
        }</span>

        <span class="cov0" title="0">return dto.Case{
                Transport: dto.Transport{
                        Chars:  transport["chars"].(string),
                        Num:    transport["numbers"].(string),
                        Region: transport["region"].(string),
                },
                Camera: dto.Camera{
                        ID: camera["id"].(string),
                },
                Violation: dto.Violation{
                        ID: violation["id"].(string),
                },
                ViolationValue: violation["value"].(string),
                RequiredSkill:  skill["value"].(int64),
                Date:           date,
        }, nil</span>

}

func (p *Parser) parseCamerus3(info map[string]any) (dto.Case, error) <span class="cov0" title="0">{
        transportStr := info["transport"].(string)
        transport := []rune(transportStr)

        chars := string(transport[1:4])
        num := string(transport[0]) + string(transport[4:6])
        region := string(transport[6:])

        camera := info["camera"].(map[string]any)
        violation := info["violation"].(map[string]any)

        return dto.Case{
                Transport: dto.Transport{
                        Chars:  chars,
                        Num:    num,
                        Region: region,
                },
                Camera: dto.Camera{
                        ID: camera["id"].(string),
                },
                Violation: dto.Violation{
                        ID: violation["id"].(string),
                },
                ViolationValue: violation["value"].(string),
                RequiredSkill:  info["skill"].(int64),
                Date:           time.Unix(info["datetime"].(int64), 0),
        }, nil
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package config

import (
        "gopkg.in/yaml.v3"
        "os"
        "time"
)

type Config struct {
        ServerPort int            `yaml:"serverPort"`
        Consensus  int            `yaml:"consensus"`
        PassSalt   string         `yaml:"passSalt"`
        SigningKey string         `yaml:"signingKey"`
        Rating     RatingConfig   `yaml:"rating"`
        Postgres   PostgresConfig `yaml:"postgres"`
        RabbitMQ   RabbitMQConfig `yaml:"rabbitmq"`
        Directors  []DirectorInfo `yaml:"directors"`
}

type RatingConfig struct {
        ReportPeriod   time.Duration `yaml:"reportPeriod"`
        MinSolvedCases int           `yaml:"minSolvedCases"`
        MinExperts     int           `yaml:"minExperts"`
}

type PostgresConfig struct {
        User     string `yaml:"user"`
        Password string `yaml:"password"`
        Host     string `yaml:"host"`
        Port     int    `yaml:"port"`
        Database string `yaml:"database"`
}

type RabbitMQConfig struct {
        User     string `yaml:"user"`
        Password string `yaml:"password"`
        Host     string `yaml:"host"`
        Port     int    `yaml:"port"`
}

type DirectorInfo struct {
        Username string `yaml:"username"`
        Password string `yaml:"password"`
}

func ParseConfig(path string) (*Config, error) <span class="cov0" title="0">{
        f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cfg := &amp;Config{}
        err = yaml.NewDecoder(f).Decode(cfg)

        return cfg, err</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package converter

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/transport/rest/dto"
        "fmt"
)

type AnalyticsConverter struct {
}

func NewAnalyticsConverter() *AnalyticsConverter <span class="cov0" title="0">{
        return &amp;AnalyticsConverter{}
}</span>

func (c *AnalyticsConverter) MapDomainToDto(d domain.AnalyticsInterval) dto.AnalyticsInterval <span class="cov0" title="0">{
        return dto.AnalyticsInterval{
                Date:                 fmt.Sprintf("%04d-%02d-%02d", d.Date.Year, d.Date.Month, d.Date.Day),
                AllCases:             d.AllCases,
                CorrectCnt:           d.CorrectCnt,
                IncorrectCnt:         d.IncorrectCnt,
                UnknownCnt:           d.UnknownCnt,
                MaxConsecutiveSolved: d.MaxConsecutiveSolved,
        }
}</span>

func (c *AnalyticsConverter) MapDomainsToDtos(d []domain.AnalyticsInterval) []dto.AnalyticsInterval <span class="cov0" title="0">{
        dtos := make([]dto.AnalyticsInterval, len(d))
        for i := range d </span><span class="cov0" title="0">{
                dtos[i] = c.MapDomainToDto(d[i])
        }</span>
        <span class="cov0" title="0">return dtos</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package converter

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/transport/rest/dto"
)

type AuthConverter struct {
}

func NewAuthConverter() *AuthConverter <span class="cov0" title="0">{
        return &amp;AuthConverter{}
}</span>

func (c *AuthConverter) MapConfirmExpertDtoToDomain(confirm dto.ConfirmExpertInput) domain.ConfirmExpert <span class="cov0" title="0">{
        return domain.ConfirmExpert{
                ExpertID:    confirm.ExpertID,
                IsConfirmed: confirm.IsConfirmed,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package converter

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/transport/rest/dto"
)

type CameraConverter struct {
}

func NewCameraConverter() *CameraConverter <span class="cov0" title="0">{
        return &amp;CameraConverter{}
}</span>

func (c *CameraConverter) MapRegisterCameraDtoToDomain(camera dto.CameraIn,
        signUp dto.SignUp,
) domain.RegisterCamera <span class="cov0" title="0">{
        return domain.RegisterCamera{
                Camera: domain.Camera{
                        ID:         "",
                        CameraType: domain.CameraType{ID: camera.CameraTypeID},
                        Latitude:   camera.Latitude,
                        Longitude:  camera.Longitude,
                        ShortDesc:  camera.ShortDesc,
                },
                Username: signUp.Username,
                Password: signUp.Password,
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package converter

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/transport/rest/dto"
)

type CaseConverter struct{}

func NewCaseConverter() *CaseConverter <span class="cov0" title="0">{
        return &amp;CaseConverter{}
}</span>

func (c *CaseConverter) MapDtoToDomain(dto dto.Case) domain.Case <span class="cov0" title="0">{
        return domain.Case{
                Transport: domain.Transport{
                        Chars:  dto.Transport.Chars,
                        Num:    dto.Transport.Num,
                        Region: dto.Transport.Region,
                },
                Camera: domain.Camera{
                        ID: dto.Camera.ID,
                },
                Violation: domain.Violation{
                        ID: dto.Violation.ID,
                },
                ViolationValue: dto.ViolationValue,
                RequiredSkill:  dto.RequiredSkill,
                Date:           dto.Date,
        }
}</span>

func (c *CaseConverter) MapDomainsToDto(cases []domain.Case) []dto.Case <span class="cov0" title="0">{
        dtos := make([]dto.Case, 0, len(cases))
        for _, c := range cases </span><span class="cov0" title="0">{
                cDto := dto.Case{
                        ID: c.ID,
                        Transport: dto.Transport{
                                ID:     c.Transport.ID,
                                Chars:  c.Transport.Chars,
                                Num:    c.Transport.Num,
                                Region: c.Transport.Region,
                        },
                        Camera: dto.Camera{
                                ID:           c.Camera.ID,
                                CameraTypeID: c.Camera.CameraType.ID,
                                Latitude:     c.Camera.Latitude,
                                Longitude:    c.Camera.Longitude,
                                ShortDesc:    c.Camera.ShortDesc,
                        },
                        Violation: dto.Violation{
                                ID:         c.Violation.ID,
                                Name:       c.Violation.Name,
                                FineAmount: c.Violation.FineAmount,
                        },
                        ViolationValue: c.ViolationValue,
                        RequiredSkill:  c.RequiredSkill,
                        IsSolved:       c.IsSolved,
                        FineDecision:   c.FineDecision,
                        Date:           c.Date,
                }

                dtos = append(dtos, cDto)
        }</span>

        <span class="cov0" title="0">return dtos</span>
}

func (c *CaseConverter) MapDomainToDto(d domain.Case) dto.Case <span class="cov0" title="0">{
        return dto.Case{
                ID: d.ID,
                Transport: dto.Transport{
                        ID:     d.Transport.ID,
                        Chars:  d.Transport.Chars,
                        Num:    d.Transport.Num,
                        Region: d.Transport.Region,
                        Person: &amp;dto.Person{
                                ID: d.Transport.Person.ID,
                        },
                },
                Camera: dto.Camera{
                        ID:           d.Camera.ID,
                        CameraTypeID: d.Camera.CameraType.ID,
                        Latitude:     d.Camera.Latitude,
                        Longitude:    d.Camera.Longitude,
                        ShortDesc:    d.Camera.ShortDesc,
                },
                Violation: dto.Violation{
                        ID:         d.Violation.ID,
                        Name:       d.Violation.Name,
                        FineAmount: d.Violation.FineAmount,
                },
                ViolationValue: d.ViolationValue,
                RequiredSkill:  d.RequiredSkill,
                IsSolved:       d.IsSolved,
                FineDecision:   d.FineDecision,
        }
}</span>

func (c *CaseConverter) MapCaseWithPersonToDTO(d domain.Case) dto.Case <span class="cov0" title="0">{
        return dto.Case{
                ID: d.ID,
                Transport: dto.Transport{
                        ID:    d.Transport.ID,
                        Chars: d.Transport.Chars,
                        Num:   d.Transport.Num,
                        Person: &amp;dto.Person{
                                ID:       d.Transport.Person.ID,
                                PhoneNum: d.Transport.Person.PhoneNum,
                                Email:    d.Transport.Person.Email,
                                VkID:     d.Transport.Person.VkID,
                                TgID:     d.Transport.Person.TgID,
                        },
                },
                Camera: dto.Camera{
                        ID:           d.Camera.ID,
                        CameraTypeID: d.Camera.CameraType.ID,
                        Latitude:     d.Camera.Latitude,
                        Longitude:    d.Camera.Longitude,
                        ShortDesc:    d.Camera.ShortDesc,
                },
                Violation: dto.Violation{
                        ID:         d.Violation.ID,
                        Name:       d.Violation.Name,
                        FineAmount: d.Violation.FineAmount,
                },
                ViolationValue: d.ViolationValue,
                RequiredSkill:  d.RequiredSkill,
                Date:           d.Date,
                IsSolved:       d.IsSolved,
                FineDecision:   d.FineDecision,
        }
}</span>

func (c *CaseConverter) MapCaseStatusToDto(d domain.CaseStatus) dto.CaseStatus <span class="cov0" title="0">{
        assessments := make([]dto.CaseAssessment, 0)
        for _, assessment := range d.CaseAssessments </span><span class="cov0" title="0">{
                assessments = append(assessments, dto.CaseAssessment{
                        ExpertID: assessment.ExpertID, IsExpertSolve: assessment.IsExpertSolve, FineDecision: assessment.FineDecision},
                )
        }</span>

        <span class="cov0" title="0">return dto.CaseStatus{
                CaseID:          d.CaseID,
                ViolationValue:  d.ViolationValue,
                RequiredSkill:   d.RequiredSkill,
                CaseDate:        d.CaseDate,
                IsSolved:        d.IsSolved,
                FineDecision:    d.FineDecision,
                CaseAssessments: assessments,
        }</span>
}

func (c *CaseConverter) MapCaseStatusesToDto(d []domain.CaseStatus) []dto.CaseStatus <span class="cov0" title="0">{
        statusesDto := make([]dto.CaseStatus, len(d))
        for i := range d </span><span class="cov0" title="0">{
                statusesDto[i] = c.MapCaseStatusToDto(d[i])
        }</span>

        <span class="cov0" title="0">return statusesDto</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package converter

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/transport/rest/dto"
)

type CaseDecisionConverter struct {
}

func NewCaseDecisionConverter() *CaseDecisionConverter <span class="cov0" title="0">{
        return &amp;CaseDecisionConverter{}
}</span>

func (c *CaseDecisionConverter) MapDtoToDomain(decision dto.Decision, expert domain.Expert) domain.Decision <span class="cov0" title="0">{
        return domain.Decision{
                CaseID:       decision.CaseID,
                Expert:       expert,
                FineDecision: decision.FineDecision,
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package converter

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/transport/rest/dto"
)

type PaginationConverter struct {
}

func NewPaginationConverter() *PaginationConverter <span class="cov0" title="0">{
        return &amp;PaginationConverter{}
}</span>

func (c *PaginationConverter) MapDomainToDto(pagination domain.Pagination) dto.Pagination <span class="cov0" title="0">{
        return dto.Pagination{
                Next:          pagination.Next,
                Previous:      pagination.Next,
                RecordPerPage: pagination.RecordPerPage,
                CurrentPage:   pagination.CurrentPage,
                TotalPage:     pagination.TotalPage,
        }
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package converter

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/transport/rest/dto"
)

type RatingConverter struct {
}

func NewRatingConverter() *RatingConverter <span class="cov0" title="0">{
        return &amp;RatingConverter{}
}</span>

func (c *RatingConverter) MapDomainToDto(d domain.RatingInfo) dto.RatingInfo <span class="cov0" title="0">{
        return dto.RatingInfo{
                ExpertID:        d.ExpertID,
                Username:        d.Username,
                CompetenceSkill: d.CompetenceSkill,
                CorrectCnt:      d.CorrectCnt,
                IncorrectCnt:    d.IncorrectCnt,
        }
}</span>

func (c *RatingConverter) MapSliceDomainToDto(domains []domain.RatingInfo) []dto.RatingInfo <span class="cov0" title="0">{
        dtos := make([]dto.RatingInfo, len(domains))
        for i := range domains </span><span class="cov0" title="0">{
                dtos[i] = c.MapDomainToDto(domains[i])
        }</span>
        <span class="cov0" title="0">return dtos</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package converter

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/transport/rest/dto"
)

type SolvedCasesConverter struct {
}

func NewSolvedCasesConverter() *SolvedCasesConverter <span class="cov0" title="0">{
        return &amp;SolvedCasesConverter{}
}</span>

func (c *SolvedCasesConverter) MapParamsDtoToDomain(params dto.SolvedCasesParams) domain.SolvedCasesParams <span class="cov0" title="0">{
        return domain.SolvedCasesParams{
                CameraID:      params.CameraID,
                RequiredSkill: params.RequiredSkill,
                ViolationID:   params.ViolationID,
                StartTime:     params.StartTime,
                EndTime:       params.EndTime,
        }
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package converter

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/transport/rest/dto"
)

type UserInfoConverter struct {
}

func NewUserInfoConverter() *UserInfoConverter <span class="cov0" title="0">{
        return &amp;UserInfoConverter{}
}</span>

func (c *UserInfoConverter) MapSignUpToUserInfo(signUp dto.SignUp) domain.UserInfo <span class="cov0" title="0">{
        return domain.UserInfo{
                Username: signUp.Username,
                Password: signUp.Password,
        }
}</span>

func (c *UserInfoConverter) MapSignInToUserInfo(signIn dto.SignInInput) domain.UserInfo <span class="cov0" title="0">{
        return domain.UserInfo{
                Username: signIn.Username,
                Password: signIn.Password,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package domain

import "time"

type Date struct {
        Year  int
        Month time.Month
        Day   int
}

func NewDate(year int, month time.Month, day int) Date <span class="cov0" title="0">{
        return Date{Year: year, Month: month, Day: day}
}</span>

func (d *Date) Before(another Date) bool <span class="cov0" title="0">{
        return time.Date(d.Year, d.Month, d.Day, 0, 0, 0, 0, time.UTC).
                Before(time.Date(another.Year, another.Month, another.Day, 0, 0, 0, 0, time.UTC))
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">// Code generated by mockery v2.42.1. DO NOT EDIT.

package mocks

import (
        domain "TrafficPolice/internal/domain"

        mock "github.com/stretchr/testify/mock"

        uuid "github.com/google/uuid"
)

// AuthRepo is an autogenerated mock type for the AuthRepo type
type AuthRepo struct {
        mock.Mock
}

// CheckUserExists provides a mock function with given fields: username
func (_m *AuthRepo) CheckUserExists(username string) bool <span class="cov8" title="1">{
        ret := _m.Called(username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for CheckUserExists")</span>
        }

        <span class="cov8" title="1">var r0 bool
        if rf, ok := ret.Get(0).(func(string) bool); ok </span><span class="cov0" title="0">{
                r0 = rf(username)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(bool)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// ConfirmExpert provides a mock function with given fields: data
func (_m *AuthRepo) ConfirmExpert(data domain.ConfirmExpert) error <span class="cov8" title="1">{
        ret := _m.Called(data)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ConfirmExpert")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(domain.ConfirmExpert) error); ok </span><span class="cov0" title="0">{
                r0 = rf(data)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// InsertCamera provides a mock function with given fields: camera, userID
func (_m *AuthRepo) InsertCamera(camera domain.Camera, userID uuid.UUID) (string, error) <span class="cov8" title="1">{
        ret := _m.Called(camera, userID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for InsertCamera")</span>
        }

        <span class="cov8" title="1">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(domain.Camera, uuid.UUID) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(camera, userID)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(domain.Camera, uuid.UUID) string); ok </span><span class="cov0" title="0">{
                r0 = rf(camera, userID)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(domain.Camera, uuid.UUID) error); ok </span><span class="cov0" title="0">{
                r1 = rf(camera, userID)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// InsertDirector provides a mock function with given fields: director
func (_m *AuthRepo) InsertDirector(director domain.Director) error <span class="cov8" title="1">{
        ret := _m.Called(director)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for InsertDirector")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(domain.Director) error); ok </span><span class="cov0" title="0">{
                r0 = rf(director)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// InsertExpert provides a mock function with given fields: expert
func (_m *AuthRepo) InsertExpert(expert domain.Expert) error <span class="cov8" title="1">{
        ret := _m.Called(expert)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for InsertExpert")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(domain.Expert) error); ok </span><span class="cov0" title="0">{
                r0 = rf(expert)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// InsertUser provides a mock function with given fields: user
func (_m *AuthRepo) InsertUser(user domain.UserInfo) error <span class="cov8" title="1">{
        ret := _m.Called(user)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for InsertUser")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(domain.UserInfo) error); ok </span><span class="cov0" title="0">{
                r0 = rf(user)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// SignIn provides a mock function with given fields: username
func (_m *AuthRepo) SignIn(username string) (domain.UserInfo, error) <span class="cov8" title="1">{
        ret := _m.Called(username)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SignIn")</span>
        }

        <span class="cov8" title="1">var r0 domain.UserInfo
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (domain.UserInfo, error)); ok </span><span class="cov0" title="0">{
                return rf(username)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(string) domain.UserInfo); ok </span><span class="cov0" title="0">{
                r0 = rf(username)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(domain.UserInfo)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(username)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewAuthRepo creates a new instance of AuthRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAuthRepo(t interface {
        mock.TestingT
        Cleanup(func())
}) *AuthRepo <span class="cov8" title="1">{
        mock := &amp;AuthRepo{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">// Code generated by mockery v2.42.1. DO NOT EDIT.

package mocks

import (
        domain "TrafficPolice/internal/domain"

        mock "github.com/stretchr/testify/mock"

        time "time"
)

// CaseRepo is an autogenerated mock type for the CaseRepo type
type CaseRepo struct {
        mock.Mock
}

// GetCaseByID provides a mock function with given fields: caseID
func (_m *CaseRepo) GetCaseByID(caseID string) (domain.Case, error) <span class="cov0" title="0">{
        ret := _m.Called(caseID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetCaseByID")</span>
        }

        <span class="cov0" title="0">var r0 domain.Case
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (domain.Case, error)); ok </span><span class="cov0" title="0">{
                return rf(caseID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) domain.Case); ok </span><span class="cov0" title="0">{
                r0 = rf(caseID)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(domain.Case)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(caseID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetCaseWithPersonInfo provides a mock function with given fields: caseID
func (_m *CaseRepo) GetCaseWithPersonInfo(caseID string) (domain.Case, error) <span class="cov0" title="0">{
        ret := _m.Called(caseID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetCaseWithPersonInfo")</span>
        }

        <span class="cov0" title="0">var r0 domain.Case
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (domain.Case, error)); ok </span><span class="cov0" title="0">{
                return rf(caseID)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(string) domain.Case); ok </span><span class="cov0" title="0">{
                r0 = rf(caseID)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Get(0).(domain.Case)
        }</span>

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(caseID)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// InsertCase provides a mock function with given fields: c
func (_m *CaseRepo) InsertCase(c domain.Case) (string, error) <span class="cov8" title="1">{
        ret := _m.Called(c)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for InsertCase")</span>
        }

        <span class="cov8" title="1">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(domain.Case) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(c)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(domain.Case) string); ok </span><span class="cov0" title="0">{
                r0 = rf(c)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(domain.Case) error); ok </span><span class="cov0" title="0">{
                r1 = rf(c)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// SetCaseFineDecision provides a mock function with given fields: caseID, fineDecision, solvedAt
func (_m *CaseRepo) SetCaseFineDecision(caseID string, fineDecision bool, solvedAt time.Time) error <span class="cov0" title="0">{
        ret := _m.Called(caseID, fineDecision, solvedAt)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SetCaseFineDecision")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string, bool, time.Time) error); ok </span><span class="cov0" title="0">{
                r0 = rf(caseID, fineDecision, solvedAt)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// UpdateCaseRequiredSkill provides a mock function with given fields: caseID, requiredSkill
func (_m *CaseRepo) UpdateCaseRequiredSkill(caseID string, requiredSkill int) error <span class="cov0" title="0">{
        ret := _m.Called(caseID, requiredSkill)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateCaseRequiredSkill")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func(string, int) error); ok </span><span class="cov0" title="0">{
                r0 = rf(caseID, requiredSkill)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewCaseRepo creates a new instance of CaseRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewCaseRepo(t interface {
        mock.TestingT
        Cleanup(func())
}) *CaseRepo <span class="cov8" title="1">{
        mock := &amp;CaseRepo{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Code generated by mockery v2.42.1. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// PaginationRepo is an autogenerated mock type for the PaginationRepo type
type PaginationRepo struct {
        mock.Mock
}

// GetRecordsCount provides a mock function with given fields: table
func (_m *PaginationRepo) GetRecordsCount(table string) (int, error) <span class="cov8" title="1">{
        ret := _m.Called(table)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetRecordsCount")</span>
        }

        <span class="cov8" title="1">var r0 int
        var r1 error
        if rf, ok := ret.Get(0).(func(string) (int, error)); ok </span><span class="cov0" title="0">{
                return rf(table)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(string) int); ok </span><span class="cov0" title="0">{
                r0 = rf(table)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(int)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(table)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewPaginationRepo creates a new instance of PaginationRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewPaginationRepo(t interface {
        mock.TestingT
        Cleanup(func())
}) *PaginationRepo <span class="cov8" title="1">{
        mock := &amp;PaginationRepo{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Code generated by mockery v2.42.1. DO NOT EDIT.

package mocks

import (
        domain "TrafficPolice/internal/domain"

        mock "github.com/stretchr/testify/mock"
)

// RatingRepo is an autogenerated mock type for the RatingRepo type
type RatingRepo struct {
        mock.Mock
}

// ClearRating provides a mock function with given fields:
func (_m *RatingRepo) ClearRating() error <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for ClearRating")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func() error); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// GetExpertsRating provides a mock function with given fields: minSolvedCases
func (_m *RatingRepo) GetExpertsRating(minSolvedCases int) ([]domain.ExpertRating, error) <span class="cov0" title="0">{
        ret := _m.Called(minSolvedCases)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetExpertsRating")</span>
        }

        <span class="cov0" title="0">var r0 []domain.ExpertRating
        var r1 error
        if rf, ok := ret.Get(0).(func(int) ([]domain.ExpertRating, error)); ok </span><span class="cov0" title="0">{
                return rf(minSolvedCases)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(int) []domain.ExpertRating); ok </span><span class="cov0" title="0">{
                r0 = rf(minSolvedCases)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]domain.ExpertRating)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(int) error); ok </span><span class="cov0" title="0">{
                r1 = rf(minSolvedCases)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetRating provides a mock function with given fields:
func (_m *RatingRepo) GetRating() ([]domain.RatingInfo, error) <span class="cov0" title="0">{
        ret := _m.Called()

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetRating")</span>
        }

        <span class="cov0" title="0">var r0 []domain.RatingInfo
        var r1 error
        if rf, ok := ret.Get(0).(func() ([]domain.RatingInfo, error)); ok </span><span class="cov0" title="0">{
                return rf()
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func() []domain.RatingInfo); ok </span><span class="cov0" title="0">{
                r0 = rf()
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]domain.RatingInfo)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func() error); ok </span><span class="cov0" title="0">{
                r1 = rf()
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// GetSolvedCaseDecisions provides a mock function with given fields: caseDecision
func (_m *RatingRepo) GetSolvedCaseDecisions(caseDecision domain.CaseDecisionInfo) ([]domain.ExpertCaseDecision, error) <span class="cov0" title="0">{
        ret := _m.Called(caseDecision)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetSolvedCaseDecisions")</span>
        }

        <span class="cov0" title="0">var r0 []domain.ExpertCaseDecision
        var r1 error
        if rf, ok := ret.Get(0).(func(domain.CaseDecisionInfo) ([]domain.ExpertCaseDecision, error)); ok </span><span class="cov0" title="0">{
                return rf(caseDecision)
        }</span>
        <span class="cov0" title="0">if rf, ok := ret.Get(0).(func(domain.CaseDecisionInfo) []domain.ExpertCaseDecision); ok </span><span class="cov0" title="0">{
                r0 = rf(caseDecision)
        }</span> else<span class="cov0" title="0"> {
                if ret.Get(0) != nil </span><span class="cov0" title="0">{
                        r0 = ret.Get(0).([]domain.ExpertCaseDecision)
                }</span>
        }

        <span class="cov0" title="0">if rf, ok := ret.Get(1).(func(domain.CaseDecisionInfo) error); ok </span><span class="cov0" title="0">{
                r1 = rf(caseDecision)
        }</span> else<span class="cov0" title="0"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov0" title="0">return r0, r1</span>
}

// InsertExpertId provides a mock function with given fields: expertID
func (_m *RatingRepo) InsertExpertId(expertID string) error <span class="cov8" title="1">{
        ret := _m.Called(expertID)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for InsertExpertId")</span>
        }

        <span class="cov8" title="1">var r0 error
        if rf, ok := ret.Get(0).(func(string) error); ok </span><span class="cov0" title="0">{
                r0 = rf(expertID)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov8" title="1">return r0</span>
}

// SetRating provides a mock function with given fields: decisions
func (_m *RatingRepo) SetRating(decisions []domain.ExpertCaseDecision) error <span class="cov0" title="0">{
        ret := _m.Called(decisions)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for SetRating")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func([]domain.ExpertCaseDecision) error); ok </span><span class="cov0" title="0">{
                r0 = rf(decisions)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// UpdateCompetenceSkills provides a mock function with given fields: infos
func (_m *RatingRepo) UpdateCompetenceSkills(infos []domain.UpdateCompetenceSkill) error <span class="cov0" title="0">{
        ret := _m.Called(infos)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for UpdateCompetenceSkills")</span>
        }

        <span class="cov0" title="0">var r0 error
        if rf, ok := ret.Get(0).(func([]domain.UpdateCompetenceSkill) error); ok </span><span class="cov0" title="0">{
                r0 = rf(infos)
        }</span> else<span class="cov0" title="0"> {
                r0 = ret.Error(0)
        }</span>

        <span class="cov0" title="0">return r0</span>
}

// NewRatingRepo creates a new instance of RatingRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRatingRepo(t interface {
        mock.TestingT
        Cleanup(func())
}) *RatingRepo <span class="cov8" title="1">{
        mock := &amp;RatingRepo{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Code generated by mockery v2.42.1. DO NOT EDIT.

package mocks

import mock "github.com/stretchr/testify/mock"

// TransportRepo is an autogenerated mock type for the TransportRepo type
type TransportRepo struct {
        mock.Mock
}

// GetTransportID provides a mock function with given fields: chars, num, region
func (_m *TransportRepo) GetTransportID(chars string, num string, region string) (string, error) <span class="cov8" title="1">{
        ret := _m.Called(chars, num, region)

        if len(ret) == 0 </span><span class="cov0" title="0">{
                panic("no return value specified for GetTransportID")</span>
        }

        <span class="cov8" title="1">var r0 string
        var r1 error
        if rf, ok := ret.Get(0).(func(string, string, string) (string, error)); ok </span><span class="cov0" title="0">{
                return rf(chars, num, region)
        }</span>
        <span class="cov8" title="1">if rf, ok := ret.Get(0).(func(string, string, string) string); ok </span><span class="cov0" title="0">{
                r0 = rf(chars, num, region)
        }</span> else<span class="cov8" title="1"> {
                r0 = ret.Get(0).(string)
        }</span>

        <span class="cov8" title="1">if rf, ok := ret.Get(1).(func(string, string, string) error); ok </span><span class="cov0" title="0">{
                r1 = rf(chars, num, region)
        }</span> else<span class="cov8" title="1"> {
                r1 = ret.Error(1)
        }</span>

        <span class="cov8" title="1">return r0, r1</span>
}

// NewTransportRepo creates a new instance of TransportRepo. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTransportRepo(t interface {
        mock.TestingT
        Cleanup(func())
}) *TransportRepo <span class="cov8" title="1">{
        mock := &amp;TransportRepo{}
        mock.Mock.Test(t)

        t.Cleanup(func() </span><span class="cov8" title="1">{ mock.AssertExpectations(t) }</span>)

        <span class="cov8" title="1">return mock</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package repository

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/repository"
        "context"
        "errors"
        "github.com/google/uuid"
        "github.com/jackc/pgx/v5"
)

type authRepoPostgres struct {
        conn *pgx.Conn
}

func NewAuthRepoPostgres(conn *pgx.Conn) repository.AuthRepo <span class="cov0" title="0">{
        return &amp;authRepoPostgres{conn: conn}
}</span>

const checkUserExistsQuery = "SELECT username FROM users WHERE username = $1"

func (r *authRepoPostgres) CheckUserExists(username string) bool <span class="cov0" title="0">{
        row := r.conn.QueryRow(context.Background(), checkUserExistsQuery, username)

        var userName string
        err := row.Scan(&amp;userName)

        return err == nil
}</span>

const insertUserQuery = `INSERT INTO users (user_id, username, hash_pass, role) 
        VALUES ($1, $2, $3, $4)`

func (r *authRepoPostgres) InsertUser(user domain.UserInfo) error <span class="cov0" title="0">{
        _, err := r.conn.Exec(context.Background(), insertUserQuery,
                user.ID.String(),
                user.Username,
                user.Password,
                user.UserRole,
        )

        return err
}</span>

const insertExpertQuery = `INSERT INTO experts (expert_id, is_confirmed, user_id, competence_skill) 
        VALUES ($1, false, $2, 1)`

func (r *authRepoPostgres) InsertExpert(expert domain.Expert) error <span class="cov0" title="0">{
        _, err := r.conn.Exec(context.Background(), insertExpertQuery, expert.ID, expert.UserInfo.ID.String())
        return err
}</span>

const insertDirectorQuery = "INSERT INTO directors (director_id, user_id) VALUES ($1, $2)"

func (r *authRepoPostgres) InsertDirector(director domain.Director) error <span class="cov0" title="0">{
        _, err := r.conn.Exec(context.Background(), insertDirectorQuery, director.ID, director.User.ID)
        return err
}</span>

const signInQuery = `SELECT user_id, hash_pass, role FROM users WHERE username = $1`

func (r *authRepoPostgres) SignIn(username string) (domain.UserInfo, error) <span class="cov0" title="0">{
        row := r.conn.QueryRow(context.Background(), signInQuery, username)

        var user domain.UserInfo
        var userID string
        err := row.Scan(&amp;userID, &amp;user.Password, &amp;user.UserRole)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return domain.UserInfo{}, errs.ErrNoRows
                }</span>
                <span class="cov0" title="0">return domain.UserInfo{}, err</span>
        }
        <span class="cov0" title="0">user.ID = uuid.MustParse(userID)

        return user, nil</span>
}

const confirmExpertQuery = "UPDATE experts SET is_confirmed = $1 WHERE expert_id = $2"

func (r *authRepoPostgres) ConfirmExpert(data domain.ConfirmExpert) error <span class="cov0" title="0">{
        n, err := r.conn.Exec(context.Background(), confirmExpertQuery, data.IsConfirmed, data.ExpertID)

        if n.RowsAffected() == 0 </span><span class="cov0" title="0">{
                return errs.ErrNoRows
        }</span>
        <span class="cov0" title="0">return err</span>
}

const insertCameraQuery = `INSERT INTO cameras (
                     camera_id, camera_type_id, camera_latitude, camera_longitude, short_desc, user_id) 
                VALUES ($1, $2, $3, $4, $5, $6) RETURNING camera_id`

func (r *authRepoPostgres) InsertCamera(camera domain.Camera, userID uuid.UUID) (string, error) <span class="cov0" title="0">{
        var cameraID string
        err := r.conn.QueryRow(context.Background(), insertCameraQuery,
                camera.ID, camera.CameraType.ID, camera.Latitude, camera.Longitude, camera.ShortDesc, userID).
                Scan(&amp;cameraID)

        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return cameraID, nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package repository

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/repository"
        "context"
        "errors"
        "github.com/jackc/pgx/v5"
)

type cameraRepoPostgres struct {
        conn *pgx.Conn
}

func NewCameraRepoPostgres(conn *pgx.Conn) repository.CameraRepo <span class="cov0" title="0">{
        return &amp;cameraRepoPostgres{conn: conn}
}</span>

const addCameraTypeQuery = `INSERT INTO camera_types (camera_type_id, camera_type_name) 
VALUES ($1, $2) RETURNING camera_type_id`

func (r *cameraRepoPostgres) AddCameraType(cameraType domain.CameraType) (string, error) <span class="cov0" title="0">{
        var cameraTypeID string

        err := r.conn.QueryRow(context.Background(), addCameraTypeQuery, cameraType.ID, cameraType.Name).
                Scan(&amp;cameraTypeID)
        if err != nil </span><span class="cov0" title="0">{
                return "", errs.ErrAlreadyExists
        }</span>

        <span class="cov0" title="0">return cameraTypeID, nil</span>
}

const getCameraTypeByCameraIDQuery = `SELECT camera_type_name 
FROM camera_types as type 
JOIN cameras as c ON type.camera_type_id = c.camera_type_id
WHERE c.camera_id = $1`

func (r *cameraRepoPostgres) GetCameraTypeByCameraID(cameraID string) (string, error) <span class="cov0" title="0">{
        row := r.conn.QueryRow(context.Background(), getCameraTypeByCameraIDQuery, cameraID)

        var cameraType string
        err := row.Scan(&amp;cameraType)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return "", errs.ErrNoRows
                }</span>
                <span class="cov0" title="0">return "", err</span>
        }

        <span class="cov0" title="0">return cameraType, nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package repository

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/repository"
        "context"
        "errors"
        "github.com/jackc/pgx/v5"
        "time"
)

type caseRepoPostgres struct {
        conn *pgx.Conn
}

func NewCaseRepoPostgres(conn *pgx.Conn) repository.CaseRepo <span class="cov0" title="0">{
        return &amp;caseRepoPostgres{conn: conn}
}</span>

const insertCaseQuery = `INSERT INTO cases (case_id, transport_id, camera_id, 
                   violation_id, violation_value, required_skill, case_date, is_solved, fine_decision, solved_at) 
                VALUES ($1, $2, $3, $4, $5, $6, $7, false, false, NULL) RETURNING case_id`

func (r *caseRepoPostgres) InsertCase(c domain.Case) (string, error) <span class="cov0" title="0">{
        var caseID string

        err := r.conn.QueryRow(context.Background(), insertCaseQuery,
                c.ID, c.Transport.ID, c.Camera.ID, c.Violation.ID, c.ViolationValue, c.RequiredSkill, c.Date,
        ).Scan(&amp;caseID)

        return caseID, err
}</span>

const getCaseByIDQuery = `SELECT c.case_id, t.transport_id, t.transport_chars, 
       t.transport_nums, t.region, t.person_id, cam.camera_type_id,
       cam.camera_latitude, cam.camera_longitude, cam.short_desc, v.violation_name, v.fine_amount,
       c.violation_value, c.required_skill, c.case_date,
       c.is_solved, c.fine_decision
FROM cases as c
JOIN transports AS t ON c.transport_id = t.transport_id
JOIN violations AS v ON c.violation_id = v.violation_id
JOIN cameras AS cam ON c.camera_id = cam.camera_id
WHERE c.case_id = $1
LIMIT 1`

func (r *caseRepoPostgres) GetCaseByID(caseID string) (domain.Case, error) <span class="cov0" title="0">{
        c := domain.Case{Transport: domain.Transport{Person: &amp;domain.Person{}}, Camera: domain.Camera{}, Violation: domain.Violation{}}

        row := r.conn.QueryRow(context.Background(), getCaseByIDQuery, caseID)

        err := row.Scan(&amp;c.ID, &amp;c.Transport.ID, &amp;c.Transport.Chars, &amp;c.Transport.Num, &amp;c.Transport.Region,
                &amp;c.Transport.Person.ID, &amp;c.Camera.CameraType.ID, &amp;c.Camera.Latitude, &amp;c.Camera.Longitude,
                &amp;c.Camera.ShortDesc, &amp;c.Violation.Name, &amp;c.Violation.FineAmount, &amp;c.ViolationValue,
                &amp;c.RequiredSkill, &amp;c.Date, &amp;c.IsSolved, &amp;c.FineDecision)

        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                return domain.Case{}, errs.ErrNoCase
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return domain.Case{}, err
        }</span>

        <span class="cov0" title="0">return c, nil</span>
}

const setCaseFineDecisionQuery = `UPDATE cases
SET fine_decision = $1, is_solved = true, solved_at = $2
WHERE case_id = $3`

func (r *caseRepoPostgres) SetCaseFineDecision(caseID string, fineDecision bool, solvedAt time.Time) error <span class="cov0" title="0">{
        _, err := r.conn.Exec(context.Background(), setCaseFineDecisionQuery, fineDecision, solvedAt, caseID)
        return err
}</span>

const updateCaseRequiredSkillQuery = `UPDATE cases
SET required_skill = $1
WHERE case_id = $2`

func (r *caseRepoPostgres) UpdateCaseRequiredSkill(caseID string, requiredSkill int) error <span class="cov0" title="0">{
        _, err := r.conn.Exec(context.Background(), updateCaseRequiredSkillQuery, requiredSkill, caseID)
        return err
}</span>

const getCaseWithPersonInfoQuery = `SELECT c.case_id, t.transport_id, t.transport_chars, 
       t.transport_nums, t.region, p.id, p.phone_num, p.email, p.vk_id, p.tg_id, 
       cam.camera_id ,cam.camera_type_id, cam.camera_latitude, cam.camera_longitude, cam.short_desc, 
       v.violation_id, v.violation_name, v.fine_amount, 
       c.violation_value, c.required_skill, c.case_date, c.is_solved, c.fine_decision
FROM cases as c
JOIN transports AS t ON c.transport_id = t.transport_id
JOIN persons AS p ON t.person_id = p.id
JOIN violations AS v ON c.violation_id = v.violation_id
JOIN cameras AS cam ON c.camera_id = cam.camera_id
WHERE c.case_id = $1
LIMIT 1`

func (r *caseRepoPostgres) GetCaseWithPersonInfo(caseID string) (domain.Case, error) <span class="cov0" title="0">{
        c := domain.Case{Transport: domain.Transport{Person: &amp;domain.Person{}}, Camera: domain.Camera{}, Violation: domain.Violation{}}

        row := r.conn.QueryRow(context.Background(), getCaseWithPersonInfoQuery, caseID)

        err := row.Scan(&amp;c.ID, &amp;c.Transport.ID, &amp;c.Transport.Chars, &amp;c.Transport.Num,
                &amp;c.Transport.Region, &amp;c.Transport.Person.ID, &amp;c.Transport.Person.PhoneNum,
                &amp;c.Transport.Person.Email, &amp;c.Transport.Person.VkID, &amp;c.Transport.Person.TgID,
                &amp;c.Camera.ID, &amp;c.Camera.CameraType.ID, &amp;c.Camera.Latitude, &amp;c.Camera.Longitude,
                &amp;c.Camera.ShortDesc, &amp;c.Violation.ID, &amp;c.Violation.Name, &amp;c.Violation.FineAmount,
                &amp;c.ViolationValue, &amp;c.RequiredSkill, &amp;c.Date, &amp;c.IsSolved, &amp;c.FineDecision)

        if err != nil </span><span class="cov0" title="0">{
                return domain.Case{}, err
        }</span>
        <span class="cov0" title="0">return c, nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package repository

import (
        "TrafficPolice/internal/repository"
        "context"
        "github.com/jackc/pgx/v5"
        "log"
)

type checkerRepoPostgres struct {
        conn *pgx.Conn
}

func NewCheckerRepoPostgres(conn *pgx.Conn) repository.CheckerRepo <span class="cov0" title="0">{
        return &amp;checkerRepoPostgres{conn: conn}
}</span>

const checkExpertExistsQuery = `SELECT user_id FROM experts WHERE expert_id = $1`

func (r *checkerRepoPostgres) CheckExpertExists(expertID string) (bool, error) <span class="cov0" title="0">{
        var userID string

        row := r.conn.QueryRow(context.Background(), checkExpertExistsQuery, expertID)
        err := row.Scan(&amp;userID)

        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package repository

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/repository"
        "context"
        "github.com/jackc/pgx/v5"
)

type contactInfoRepoPostgres struct {
        conn *pgx.Conn
}

func NewContactInfoRepoPostgres(conn *pgx.Conn) repository.ContactInfoRepo <span class="cov0" title="0">{
        return &amp;contactInfoRepoPostgres{conn: conn}
}</span>

func (r *contactInfoRepoPostgres) InsertContactInfo(m map[string][]*domain.Transport) error <span class="cov0" title="0">{
        batch := &amp;pgx.Batch{}

        personQuery := `INSERT INTO persons (id, phone_num, email, vk_id, tg_id) VALUES ($1, $2, $3, $4, $5)`
        transportQuery := `INSERT INTO transports(transport_id, transport_chars, transport_nums, region, person_id) VALUES ($1, $2, $3, $4, $5)`

        for _, transports := range m </span><span class="cov0" title="0">{
                if len(transports) &gt; 0 </span><span class="cov0" title="0">{
                        person := transports[0].Person
                        batch.Queue(personQuery, person.ID, person.PhoneNum, person.Email, person.VkID, person.TgID)
                }</span>
                <span class="cov0" title="0">for _, t := range transports </span><span class="cov0" title="0">{
                        batch.Queue(transportQuery, t.ID, t.Chars, t.Num, t.Region, t.Person.ID)
                }</span>
        }

        <span class="cov0" title="0">return r.conn.SendBatch(context.Background(), batch).Close()</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package repository

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/repository"
        "context"
        "errors"
        "github.com/jackc/pgx/v5"
        "log"
        "time"
)

type directorRepoPostgres struct {
        conn *pgx.Conn
}

func NewDirectorRepoPostgres(conn *pgx.Conn) repository.DirectorRepo <span class="cov0" title="0">{
        return &amp;directorRepoPostgres{conn: conn}
}</span>

const getCasesQuery = `SELECT case_id, violation_value, required_skill, case_date, is_solved, fine_decision
FROM cases`

const getCaseAssessments = `SELECT expert_id, is_expert_solve, fine_decision 
FROM expert_cases WHERE case_id = $1`

func (r *directorRepoPostgres) GetCases() ([]domain.CaseStatus, error) <span class="cov0" title="0">{
        rows, err := r.conn.Query(context.Background(), getCasesQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">statuses := make([]domain.CaseStatus, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                status := domain.CaseStatus{CaseAssessments: make([]domain.CaseAssessment, 0)}

                err = rows.Scan(&amp;status.CaseID, &amp;status.ViolationValue, &amp;status.RequiredSkill, &amp;status.CaseDate, &amp;status.IsSolved, &amp;status.FineDecision)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        continue</span>
                }

                <span class="cov0" title="0">statuses = append(statuses, status)</span>
        }

        <span class="cov0" title="0">for i := range statuses </span><span class="cov0" title="0">{
                assessmentsRows, err := r.conn.Query(context.Background(), getCaseAssessments, statuses[i].CaseID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        continue</span>
                }

                <span class="cov0" title="0">assessments := make([]domain.CaseAssessment, 0)
                for assessmentsRows.Next() </span><span class="cov0" title="0">{
                        assessment := domain.CaseAssessment{}
                        err = assessmentsRows.Scan(
                                &amp;assessment.ExpertID, &amp;assessment.IsExpertSolve, &amp;assessment.FineDecision,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println(err)
                                continue</span>
                        }

                        <span class="cov0" title="0">assessments = append(assessments, assessment)</span>
                }

                <span class="cov0" title="0">statuses[i].CaseAssessments = assessments</span>
        }

        <span class="cov0" title="0">return statuses, nil</span>
}

const getExpertIntervalCasesQuery = `SELECT ec.is_expert_solve , ec.fine_decision AS expert_fine_decision,
c.fine_decision AS case_fine_decision, ec.got_at
FROM expert_cases AS ec
JOIN cases AS c ON ec.case_id = c.case_id
WHERE expert_id = $1
AND (ec.got_at BETWEEN $2 AND $3)
ORDER BY ec.got_at`

func (r *directorRepoPostgres) GetExpertIntervalCases(
        expertID string,
        startDate time.Time,
        endDate time.Time,
) (map[domain.Date][]domain.IntervalCase, error) <span class="cov0" title="0">{
        rows, err := r.conn.Query(context.Background(), getExpertIntervalCasesQuery, expertID, startDate, endDate)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return nil, errs.ErrNoRows
                }</span>
        }

        <span class="cov0" title="0">intervals := make(map[domain.Date][]domain.IntervalCase)
        for rows.Next() </span><span class="cov0" title="0">{
                interval := domain.IntervalCase{}

                err = rows.Scan(&amp;interval.IsExpertSolve, &amp;interval.ExpertFineDecision, &amp;interval.CaseFineDecision, &amp;interval.GotAt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        continue</span>
                }

                <span class="cov0" title="0">date := domain.NewDate(interval.GotAt.Date())

                if _, ok := intervals[date]; !ok </span><span class="cov0" title="0">{
                        intervals[date] = make([]domain.IntervalCase, 0)
                }</span>
                <span class="cov0" title="0">intervals[date] = append(intervals[date], interval)</span>
        }

        <span class="cov0" title="0">return intervals, nil</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package repository

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/repository"
        "context"
        "errors"
        "github.com/jackc/pgx/v5"
)

type expertRepoPostgres struct {
        conn *pgx.Conn
}

func NewExpertRepoPostgres(conn *pgx.Conn) repository.ExpertRepo <span class="cov0" title="0">{
        return &amp;expertRepoPostgres{conn: conn}
}</span>

const getLastNotSolvedCaseQuery = `SELECT case_id FROM expert_cases 
        WHERE expert_id = $1 and is_expert_solve = false`

func (r *expertRepoPostgres) GetLastNotSolvedCaseID(expertID string) (string, error) <span class="cov0" title="0">{
        var caseID string

        row := r.conn.QueryRow(context.Background(), getLastNotSolvedCaseQuery, expertID)
        err := row.Scan(&amp;caseID)
        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                return "", errs.ErrNoLastNotSolvedCase
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return caseID, err</span>
}

const getExpertByUserIDQuery = `SELECT e.expert_id, e.is_confirmed, e.competence_skill,
       u.user_id, u.username, u.hash_pass, u.register_at, u.role
        FROM experts AS e
        JOIN users AS u on e.user_id = u.user_id
        WHERE u.user_id = $1`

func (r *expertRepoPostgres) GetExpertByUserID(userID string) (domain.Expert, error) <span class="cov0" title="0">{
        expert := domain.Expert{UserInfo: domain.UserInfo{}}

        row := r.conn.QueryRow(context.Background(), getExpertByUserIDQuery, userID)

        err := row.Scan(&amp;expert.ID, &amp;expert.IsConfirmed, &amp;expert.CompetenceSkill,
                &amp;expert.UserInfo.ID, &amp;expert.UserInfo.Username, &amp;expert.UserInfo.Password,
                &amp;expert.UserInfo.RegisterAt, &amp;expert.UserInfo.UserRole)
        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                return domain.Expert{}, errs.ErrUserNotExists
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return domain.Expert{}, err
        }</span>

        <span class="cov0" title="0">return expert, nil</span>
}

const getNotSolvedCaseQuery = `SELECT c.case_id, t.transport_id, t.transport_chars, 
       t.transport_nums, t.region, t.person_id, cam.camera_type_id,
       cam.camera_latitude, cam.camera_longitude, cam.short_desc, v.violation_name, v.fine_amount,
       c.violation_value, c.required_skill, c.case_date,
       c.is_solved, c.fine_decision
FROM cases as c
JOIN transports AS t ON c.transport_id = t.transport_id
JOIN violations AS v ON c.violation_id = v.violation_id
JOIN cameras AS cam ON c.camera_id = cam.camera_id
WHERE c.is_solved = false and c.required_skill = $1 and c.case_id 
NOT IN (
        SELECT ec.case_id FROM expert_cases as ec
        WHERE ec.expert_id = $2 and ec.is_expert_solve = true
)
LIMIT 1`

func (r *expertRepoPostgres) GetNotSolvedCase(expert domain.Expert) (domain.Case, error) <span class="cov0" title="0">{
        c := domain.Case{Transport: domain.Transport{Person: &amp;domain.Person{}},
                Camera: domain.Camera{}, Violation: domain.Violation{},
        }

        row := r.conn.QueryRow(context.Background(), getNotSolvedCaseQuery, expert.CompetenceSkill, expert.ID)

        err := row.Scan(&amp;c.ID, &amp;c.Transport.ID, &amp;c.Transport.Chars, &amp;c.Transport.Num, &amp;c.Transport.Region,
                &amp;c.Transport.Person.ID, &amp;c.Camera.CameraType.ID, &amp;c.Camera.Latitude, &amp;c.Camera.Longitude,
                &amp;c.Camera.ShortDesc, &amp;c.Violation.Name, &amp;c.Violation.FineAmount, &amp;c.ViolationValue,
                &amp;c.RequiredSkill, &amp;c.Date, &amp;c.IsSolved, &amp;c.FineDecision)

        if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                return domain.Case{}, errs.ErrNoNotSolvedCase
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return domain.Case{}, err
        }</span>

        <span class="cov0" title="0">return c, nil</span>
}

const insertNotSolvedCaseQuery = `INSERT INTO expert_cases 
    (expert_case_id, expert_id, case_id, is_expert_solve, fine_decision, got_at, solved_at) 
    VALUES ($1, $2, $3, $4, $5, $6, NULL)`

func (r *expertRepoPostgres) InsertNotSolvedCase(solvedCase domain.ExpertCase) error <span class="cov0" title="0">{
        _, err := r.conn.Exec(context.Background(), insertNotSolvedCaseQuery,
                solvedCase.ExpertCaseID,
                solvedCase.ExpertID,
                solvedCase.CaseID,
                solvedCase.IsExpertSolve,
                solvedCase.FineDecision,
                solvedCase.GotAt,
        )

        return err
}</span>

const setCaseDecisionQuery = `UPDATE expert_cases 
SET is_expert_solve = true, fine_decision = $1, solved_at = $2
WHERE expert_id = $3 and case_id = $4`

func (r *expertRepoPostgres) SetCaseDecision(decision domain.Decision) error <span class="cov0" title="0">{
        _, err := r.conn.Exec(context.Background(), setCaseDecisionQuery,
                decision.FineDecision,
                decision.SolvedAt,
                decision.Expert.ID,
                decision.CaseID,
        )

        return err
}</span>

const gGetCaseFineDecisions = `SELECT 
    SUM(CASE WHEN fine_decision = true THEN 1 ELSE 0 END) AS positive_decisions,
    SUM(CASE WHEN fine_decision = false THEN 1 ELSE 0 END) AS negative_decisions
FROM expert_cases
WHERE case_id = $1`

func (r *expertRepoPostgres) GetCaseFineDecisions(caseID string) (domain.FineDecisions, error) <span class="cov0" title="0">{
        row := r.conn.QueryRow(context.Background(), gGetCaseFineDecisions, caseID)

        var fineDecisions domain.FineDecisions
        err := row.Scan(&amp;fineDecisions.PositiveDecisions, &amp;fineDecisions.NegativeDecisions)
        return fineDecisions, err
}</span>

const getExpertsCountByRequiredSkillQuery = `SELECT COUNT(*)
FROM experts
WHERE competence_skill = $1`

func (r *expertRepoPostgres) GetExpertsCountBySkill(competenceSkill int) (int, error) <span class="cov0" title="0">{
        row := r.conn.QueryRow(context.Background(), getExpertsCountByRequiredSkillQuery, competenceSkill)

        var cnt int
        err := row.Scan(&amp;cnt)
        return cnt, err
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">package repository

import (
        "TrafficPolice/internal/repository"
        "context"
        "fmt"
        "github.com/jackc/pgx/v5"
)

type paginationRepoPostgres struct {
        conn *pgx.Conn
}

func NewPaginationRepoPostgres(conn *pgx.Conn) repository.PaginationRepo <span class="cov0" title="0">{
        return &amp;paginationRepoPostgres{
                conn: conn,
        }
}</span>

func (r *paginationRepoPostgres) GetRecordsCount(table string) (int, error) <span class="cov0" title="0">{
        sqlTableQuery := fmt.Sprintf("SELECT count(*) FROM %s", table)
        row := r.conn.QueryRow(context.Background(), sqlTableQuery)

        var recordsCount int
        err := row.Scan(&amp;recordsCount)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return recordsCount, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package repository

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/repository"
        "context"
        "github.com/jackc/pgx/v5"
        "log"
)

type ratingRepoPostgres struct {
        conn *pgx.Conn
}

func NewRatingRepoPostgres(conn *pgx.Conn) repository.RatingRepo <span class="cov0" title="0">{
        return &amp;ratingRepoPostgres{
                conn: conn,
        }
}</span>

const getSolvedCaseDecisionsQuery = `SELECT ec.expert_id, ec.fine_decision = c.fine_decision AS is_right
FROM cases AS c
JOIN expert_cases AS ec ON c.case_id = ec.case_id
WHERE ec.case_id = $1`

func (r *ratingRepoPostgres) GetSolvedCaseDecisions(
        caseDecision domain.CaseDecisionInfo,
) ([]domain.ExpertCaseDecision, error) <span class="cov0" title="0">{
        rows, err := r.conn.Query(context.Background(), getSolvedCaseDecisionsQuery, caseDecision.CaseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">solvedDecisions := make([]domain.ExpertCaseDecision, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                d := domain.ExpertCaseDecision{}
                err = rows.Scan(&amp;d.ExpertID, &amp;d.IsRight)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">solvedDecisions = append(solvedDecisions, d)</span>
        }

        <span class="cov0" title="0">return solvedDecisions, nil</span>
}

const updateCorrectCntQuery = `UPDATE rating
SET correct_cnt = correct_cnt+1
WHERE expert_id = $1`
const updateInCorrectCntQuery = `UPDATE rating
SET incorrect_cnt = incorrect_cnt+1
WHERE expert_id = $1`

func (r *ratingRepoPostgres) SetRating(decisions []domain.ExpertCaseDecision) error <span class="cov0" title="0">{
        batch := &amp;pgx.Batch{}

        for _, d := range decisions </span><span class="cov0" title="0">{
                if d.IsRight </span><span class="cov0" title="0">{
                        batch.Queue(updateCorrectCntQuery, d.ExpertID)
                }</span> else<span class="cov0" title="0"> {
                        batch.Queue(updateInCorrectCntQuery, d.ExpertID)
                }</span>
        }

        <span class="cov0" title="0">return r.conn.SendBatch(context.Background(), batch).Close()</span>
}

const insertExpertIdQuery = `INSERT INTO rating (expert_id, correct_cnt, incorrect_cnt)
VALUES ($1, 0, 0) ON CONFLICT DO NOTHING`

func (r *ratingRepoPostgres) InsertExpertId(expertID string) error <span class="cov0" title="0">{
        _, err := r.conn.Exec(context.Background(), insertExpertIdQuery, expertID)
        return err
}</span>

const getRatingQuery = `SELECT r.expert_id, u.username, e.competence_skill,
       r.correct_cnt, r.incorrect_cnt
FROM rating AS r 
JOIN experts as e ON r.expert_id = e.expert_id
JOIN users AS u ON e.user_id = u.user_id`

func (r *ratingRepoPostgres) GetRating() ([]domain.RatingInfo, error) <span class="cov0" title="0">{
        rows, err := r.conn.Query(context.Background(), getRatingQuery)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">infos := make([]domain.RatingInfo, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                info := domain.RatingInfo{}
                err = rows.Scan(&amp;info.ExpertID, &amp;info.Username, &amp;info.CompetenceSkill, &amp;info.CorrectCnt, &amp;info.IncorrectCnt)

                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">infos = append(infos, info)</span>
        }

        <span class="cov0" title="0">return infos, nil</span>
}

const getExpertsRatingQuery = `SELECT expert_id, correct_cnt, incorrect_cnt
FROM rating
WHERE correct_cnt + incorrect_cnt &gt;= $1`

func (r *ratingRepoPostgres) GetExpertsRating(minSolvedCases int) ([]domain.ExpertRating, error) <span class="cov0" title="0">{
        rows, err := r.conn.Query(context.Background(), getExpertsRatingQuery, minSolvedCases)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ratings := make([]domain.ExpertRating, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                rating := domain.ExpertRating{}
                err = rows.Scan(&amp;rating.ExpertID, &amp;rating.CorrectCnt, &amp;rating.IncorrectCnt)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        continue</span>
                }

                <span class="cov0" title="0">ratings = append(ratings, rating)</span>
        }

        <span class="cov0" title="0">return ratings, nil</span>
}

const increaseCompetenceSkill = `UPDATE experts
SET competence_skill = competence_skill+1 
WHERE expert_id = $1`

const decreaseCompetenceSkill = `UPDATE experts
SET competence_skill = CASE
        WHEN competence_skill &gt; 1 THEN competence_skill - 1
        ELSE 1
END
WHERE expert_id = $1`

func (r *ratingRepoPostgres) UpdateCompetenceSkills(infos []domain.UpdateCompetenceSkill) error <span class="cov0" title="0">{
        batch := &amp;pgx.Batch{}

        for _, info := range infos </span><span class="cov0" title="0">{
                if info.ShouldIncrease </span><span class="cov0" title="0">{
                        batch.Queue(increaseCompetenceSkill, info.ExpertID)
                }</span> else<span class="cov0" title="0"> {
                        batch.Queue(decreaseCompetenceSkill, info.ExpertID)
                }</span>
        }

        <span class="cov0" title="0">return r.conn.SendBatch(context.Background(), batch).Close()</span>
}

const clearRatingQuery = `UPDATE rating
SET correct_cnt = 0, incorrect_cnt = 0`

func (r *ratingRepoPostgres) ClearRating() error <span class="cov0" title="0">{
        _, err := r.conn.Exec(context.Background(), clearRatingQuery)
        return err
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package repository

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/repository"
        "context"
        "github.com/jackc/pgx/v5"
        "log"
)

type trainingRepoPostgres struct {
        conn *pgx.Conn
}

func NewTrainingRepoPostgres(conn *pgx.Conn) repository.TrainingRepo <span class="cov0" title="0">{
        return &amp;trainingRepoPostgres{
                conn: conn,
        }
}</span>

const getSolvedCasesByParamsQuery = `SELECT c.case_id, c.violation_value, c.required_skill, 
        c.case_date, c.fine_decision, t.transport_id, t.transport_chars, t.transport_nums,
        t.region, cam.camera_id, type.camera_type_id, type.camera_type_name, 
        cam.camera_latitude, cam.camera_longitude, cam.short_desc,
        v.violation_id, v.violation_name, v.fine_amount
FROM cases AS c
JOIN transports AS t ON c.transport_id = t.transport_id 
JOIN cameras AS cam ON c.camera_id = cam.camera_id
JOIN camera_types AS type ON cam.camera_type_id = type.camera_type_id
JOIN violations AS v ON c.violation_id = v.violation_id
WHERE c.is_solved = true AND cam.camera_id = $1 AND c.required_skill = $2
AND v.violation_id = $3
AND c.case_date BETWEEN $4 and $5
LIMIT $6
OFFSET $7`

func (r *trainingRepoPostgres) GetSolvedCasesByParams(
        params domain.SolvedCasesParams,
        paginationParams domain.PaginationParams,
) ([]domain.Case, error) <span class="cov0" title="0">{
        offset := paginationParams.Limit * (paginationParams.Page - 1)

        rows, err := r.conn.Query(context.Background(), getSolvedCasesByParamsQuery,
                params.CameraID, params.RequiredSkill, params.ViolationID, params.StartTime, params.EndTime,
                paginationParams.Limit, offset,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cases := make([]domain.Case, 0)
        for rows.Next() </span><span class="cov0" title="0">{
                var c domain.Case

                err = rows.Scan(&amp;c.ID, &amp;c.ViolationValue, &amp;c.RequiredSkill, &amp;c.Date, &amp;c.FineDecision,
                        &amp;c.Transport.ID, &amp;c.Transport.Chars, &amp;c.Transport.Num,
                        &amp;c.Transport.Region, &amp;c.Camera.ID, &amp;c.Camera.CameraType.ID, &amp;c.Camera.CameraType.Name,
                        &amp;c.Camera.Latitude, &amp;c.Camera.Longitude, &amp;c.Violation.ID,
                        &amp;c.Violation.ID, &amp;c.Violation.Name, &amp;c.Violation.FineAmount)

                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        continue</span>
                }

                <span class="cov0" title="0">cases = append(cases, c)</span>
        }

        <span class="cov0" title="0">if len(cases) == 0 </span><span class="cov0" title="0">{
                return nil, errs.ErrNoRows
        }</span>

        <span class="cov0" title="0">return cases, nil</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package repository

import (
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/repository"
        "context"
        "errors"
        "github.com/jackc/pgx/v5"
)

type transportRepoPostgres struct {
        conn *pgx.Conn
}

func NewTransportRepoPostgres(conn *pgx.Conn) repository.TransportRepo <span class="cov0" title="0">{
        return &amp;transportRepoPostgres{
                conn: conn,
        }
}</span>

const getTransportIDQuery = `SELECT transport_id FROM transports
WHERE transport_chars = $1 and transport_nums = $2 and region = $3`

func (r *transportRepoPostgres) GetTransportID(chars string, num string, region string) (string, error) <span class="cov0" title="0">{
        row := r.conn.QueryRow(context.Background(), getTransportIDQuery, chars, num, region)

        var transportID string
        err := row.Scan(&amp;transportID)

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, pgx.ErrNoRows) </span><span class="cov0" title="0">{
                        return "", errs.ErrNoTransport
                }</span>
        }
        <span class="cov0" title="0">return transportID, nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package repository

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/repository"
        "context"
        "github.com/jackc/pgx/v5"
)

type violationDBPostgres struct {
        conn *pgx.Conn
}

func NewViolationDBPostgres(conn *pgx.Conn) repository.ViolationRepo <span class="cov0" title="0">{
        return &amp;violationDBPostgres{conn: conn}
}</span>

func (db *violationDBPostgres) InsertViolations(violations []*domain.Violation) error <span class="cov0" title="0">{
        batch := &amp;pgx.Batch{}

        query := `INSERT INTO violations (violation_id, violation_name, fine_amount) VALUES ($1, $2, $3)`
        for _, v := range violations </span><span class="cov0" title="0">{
                batch.Queue(query, v.ID, v.Name, v.FineAmount)
        }</span>

        <span class="cov0" title="0">return db.conn.SendBatch(context.Background(), batch).Close()</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package service

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/repository"
        "TrafficPolice/internal/tokens"
        "TrafficPolice/pkg/hash"
        "github.com/google/uuid"
        "time"
)

type AuthService interface {
        RegisterExpert(input domain.UserInfo) error
        RegisterCamera(info domain.RegisterCamera) (string, error)
        RegisterDirectors(users []domain.UserInfo) error
        SignIn(input domain.UserInfo) (domain.Tokens, error)
        ConfirmExpert(data domain.ConfirmExpert) error
        ParseAccessToken(accessToken string) (tokens.TokenInfo, error)
}

type authService struct {
        authRepo       repository.AuthRepo
        ratingRepo     repository.RatingRepo
        hasher         hash.PasswordHasher
        tokenManager   tokens.TokenManager
        accessTokenTTL time.Duration
}

func NewAuthService(
        repo repository.AuthRepo,
        ratingRepo repository.RatingRepo,
        hasher hash.PasswordHasher,
        tokenManager tokens.TokenManager,
) AuthService <span class="cov8" title="1">{
        return &amp;authService{
                authRepo:       repo,
                ratingRepo:     ratingRepo,
                hasher:         hasher,
                tokenManager:   tokenManager,
                accessTokenTTL: 30 * 24 * time.Hour,
        }
}</span>

func (s *authService) RegisterExpert(user domain.UserInfo) error <span class="cov8" title="1">{
        alreadyExists := s.authRepo.CheckUserExists(user.Username)
        if alreadyExists </span><span class="cov8" title="1">{
                return errs.ErrAlreadyExists
        }</span>

        <span class="cov8" title="1">hashedPass, err := s.hasher.Hash(user.Password)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">user.ID = uuid.New()
        user.Password = hashedPass
        user.UserRole = "expert"
        err = s.authRepo.InsertUser(user)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">err = s.authRepo.InsertExpert(domain.Expert{
                ID:       uuid.New().String(),
                UserInfo: user,
        })

        return err</span>
}

func (s *authService) RegisterCamera(info domain.RegisterCamera) (string, error) <span class="cov8" title="1">{
        alreadyExists := s.authRepo.CheckUserExists(info.Username)
        if alreadyExists </span><span class="cov8" title="1">{
                return "", errs.ErrAlreadyExists
        }</span>

        <span class="cov8" title="1">hashedPass, err := s.hasher.Hash(info.Password)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">userID := uuid.New()
        info.Camera.ID = uuid.New().String()

        userInfo := domain.UserInfo{
                ID:       userID,
                Username: info.Username,
                Password: hashedPass,
                UserRole: string(domain.CameraRole),
        }
        err = s.authRepo.InsertUser(userInfo)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return s.authRepo.InsertCamera(info.Camera, userID)</span>
}

func (s *authService) RegisterDirectors(users []domain.UserInfo) error <span class="cov8" title="1">{
        for i := range users </span><span class="cov8" title="1">{
                alreadyExists := s.authRepo.CheckUserExists(users[i].Username)
                if alreadyExists </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">hashedPass, err := s.hasher.Hash(users[i].Password)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">users[i].ID = uuid.New()
                users[i].Password = hashedPass
                users[i].UserRole = "director"

                err = s.authRepo.InsertUser(users[i])
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">err = s.authRepo.InsertDirector(domain.Director{
                        ID:   uuid.New(),
                        User: users[i],
                })

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (s *authService) SignIn(input domain.UserInfo) (domain.Tokens, error) <span class="cov8" title="1">{
        user, err := s.authRepo.SignIn(input.Username)
        if err != nil </span><span class="cov8" title="1">{
                return domain.Tokens{}, err
        }</span>

        <span class="cov8" title="1">inputHashPass, err := s.hasher.Hash(input.Password)
        if err != nil </span><span class="cov0" title="0">{
                return domain.Tokens{}, err
        }</span>

        <span class="cov8" title="1">if user.Password != inputHashPass </span><span class="cov8" title="1">{
                return domain.Tokens{}, errs.ErrInvalidPass
        }</span>

        <span class="cov8" title="1">accessToken, err := s.tokenManager.NewJWT(tokens.TokenInfo{
                UserID:   user.ID.String(),
                UserRole: domain.Role(user.UserRole),
        }, s.accessTokenTTL)
        if err != nil </span><span class="cov0" title="0">{
                return domain.Tokens{}, err
        }</span>

        <span class="cov8" title="1">refreshToken, err := s.tokenManager.NewRefreshToken()
        if err != nil </span><span class="cov0" title="0">{
                return domain.Tokens{}, err
        }</span>

        <span class="cov8" title="1">return domain.Tokens{AccessToken: accessToken, RefreshToken: refreshToken}, nil</span>
}

func (s *authService) ConfirmExpert(data domain.ConfirmExpert) error <span class="cov8" title="1">{
        err := s.authRepo.ConfirmExpert(data)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return s.ratingRepo.InsertExpertId(data.ExpertID)</span>
}

func (s *authService) ParseAccessToken(accessToken string) (tokens.TokenInfo, error) <span class="cov0" title="0">{
        return s.tokenManager.Parse(accessToken)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package service

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/repository"
        "github.com/google/uuid"
)

type CameraService interface {
        AddCameraType(cameraType domain.CameraType) (string, error)
        GetCameraTypeByCameraID(cameraID string) (string, error)
}

type cameraService struct {
        cameraRepo repository.CameraRepo
}

func NewCameraService(db repository.CameraRepo) CameraService <span class="cov0" title="0">{
        return &amp;cameraService{cameraRepo: db}
}</span>

func (s *cameraService) AddCameraType(cameraType domain.CameraType) (string, error) <span class="cov0" title="0">{
        id := uuid.New()
        cameraType.ID = id.String()
        return s.cameraRepo.AddCameraType(cameraType)
}</span>

func (s *cameraService) GetCameraTypeByCameraID(cameraID string) (string, error) <span class="cov0" title="0">{
        return s.cameraRepo.GetCameraTypeByCameraID(cameraID)
}</span>
</pre>
		
		<pre class="file" id="file39" style="display: none">package service

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/repository"
        "github.com/google/uuid"
)

type CaseService interface {
        AddCase(c domain.Case) (string, error)
}

type caseService struct {
        caseRepo      repository.CaseRepo
        transportRepo repository.TransportRepo
}

func NewCaseService(
        caseRepo repository.CaseRepo,
        transportRepo repository.TransportRepo,
) CaseService <span class="cov8" title="1">{
        return &amp;caseService{
                caseRepo:      caseRepo,
                transportRepo: transportRepo,
        }
}</span>

func (s *caseService) AddCase(c domain.Case) (string, error) <span class="cov8" title="1">{
        id := uuid.New()
        c.ID = id.String()
        transportID, err := s.transportRepo.GetTransportID(c.Transport.Chars, c.Transport.Num, c.Transport.Region)

        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">c.Transport.ID = transportID

        return s.caseRepo.InsertCase(c)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package service

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/repository"
        "github.com/google/uuid"
)

type ContactInfoService interface {
        InsertContactInfo(m map[string][]*domain.Transport) error
}

type contactInfoService struct {
        repo repository.ContactInfoRepo
}

func NewContactInfoService(repo repository.ContactInfoRepo) ContactInfoService <span class="cov0" title="0">{
        return &amp;contactInfoService{repo: repo}
}</span>

func (s *contactInfoService) InsertContactInfo(m map[string][]*domain.Transport) error <span class="cov0" title="0">{
        for _, transports := range m </span><span class="cov0" title="0">{
                personID := uuid.New().String()

                for i := range transports </span><span class="cov0" title="0">{
                        transports[i].Person.ID = personID
                        transports[i].ID = uuid.New().String()
                }</span>
        }
        <span class="cov0" title="0">return s.repo.InsertContactInfo(m)</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package service

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/repository"
        "sort"
        "time"
)

type DirectorService interface {
        GetCases() ([]domain.CaseStatus, error)
        GetExpertAnalytics(expertID string, startTime time.Time, endTime time.Time) ([]domain.AnalyticsInterval, error)
}

type directorService struct {
        directorRepo repository.DirectorRepo
        checkerRepo  repository.CheckerRepo
}

func NewDirectorService(
        directorRepo repository.DirectorRepo,
        checkerRepo repository.CheckerRepo,
) DirectorService <span class="cov0" title="0">{
        return &amp;directorService{
                directorRepo: directorRepo,
                checkerRepo:  checkerRepo,
        }
}</span>

func (s *directorService) GetCases() ([]domain.CaseStatus, error) <span class="cov0" title="0">{
        cases, err := s.directorRepo.GetCases()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(cases) == 0 </span><span class="cov0" title="0">{
                return nil, errs.ErrNoRows
        }</span>
        <span class="cov0" title="0">return cases, nil</span>
}

func (s *directorService) GetExpertAnalytics(
        expertID string,
        startTime time.Time,
        endTime time.Time,
) ([]domain.AnalyticsInterval, error) <span class="cov0" title="0">{
        isExpertExists, err := s.checkerRepo.CheckExpertExists(expertID)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if !isExpertExists </span><span class="cov0" title="0">{
                return nil, errs.ErrExpertNotExists
        }</span>

        <span class="cov0" title="0">intervalsCases, err := s.directorRepo.GetExpertIntervalCases(expertID, startTime, endTime)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">analyticsIntervals := make([]domain.AnalyticsInterval, 0)
        for date, interval := range intervalsCases </span><span class="cov0" title="0">{
                sort.Slice(interval, func(i, j int) bool </span><span class="cov0" title="0">{
                        return interval[i].GotAt.Before(interval[j].GotAt)
                }</span>)

                <span class="cov0" title="0">maxConsecutive := 0
                currentConsecutive := 0
                correctCnt := 0
                incorrectCnt := 0
                unknownCnt := 0

                for i := 0; i &lt; len(interval); i++ </span><span class="cov0" title="0">{
                        decision := interval[i]

                        if !decision.IsExpertSolve </span><span class="cov0" title="0">{
                                unknownCnt++
                                continue</span>
                        }

                        <span class="cov0" title="0">if decision.ExpertFineDecision == decision.CaseFineDecision </span><span class="cov0" title="0">{
                                correctCnt++
                                currentConsecutive++
                        }</span> else<span class="cov0" title="0"> if decision.ExpertFineDecision != decision.CaseFineDecision </span><span class="cov0" title="0">{
                                incorrectCnt++
                                maxConsecutive = max(maxConsecutive, currentConsecutive)
                                currentConsecutive = 0
                        }</span>
                }
                <span class="cov0" title="0">maxConsecutive = max(maxConsecutive, currentConsecutive)

                analyticsIntervals = append(analyticsIntervals, domain.AnalyticsInterval{
                        Date:                 date,
                        AllCases:             len(interval),
                        CorrectCnt:           correctCnt,
                        IncorrectCnt:         incorrectCnt,
                        UnknownCnt:           unknownCnt,
                        MaxConsecutiveSolved: maxConsecutive,
                })</span>
        }

        <span class="cov0" title="0">sort.Slice(analyticsIntervals, func(i, j int) bool </span><span class="cov0" title="0">{
                return analyticsIntervals[i].Date.Before(analyticsIntervals[j].Date)
        }</span>)

        <span class="cov0" title="0">return analyticsIntervals, nil</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">package service

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/repository"
        "errors"
        "github.com/google/uuid"
        "time"
)

type ExpertService interface {
        GetExpertByUserID(userID string) (domain.Expert, error)
        GetCase(userID string) (domain.Case, error)
        SetCaseDecision(decision domain.Decision) (domain.CaseDecisionInfo, error)
        GetCaseWithPersonInfo(caseID string) (domain.Case, error)
}

type expertService struct {
        expertRepo repository.ExpertRepo
        caseRepo   repository.CaseRepo
        consensus  int
}

func NewExpertService(
        expertRepo repository.ExpertRepo,
        caseRepo repository.CaseRepo,
        consensus int,
) ExpertService <span class="cov0" title="0">{
        return &amp;expertService{
                expertRepo: expertRepo,
                caseRepo:   caseRepo,
                consensus:  consensus,
        }
}</span>

func (s *expertService) GetCase(userID string) (domain.Case, error) <span class="cov0" title="0">{
        expert, err := s.expertRepo.GetExpertByUserID(userID)
        if err != nil </span><span class="cov0" title="0">{
                return domain.Case{}, err
        }</span>

        <span class="cov0" title="0">caseID, err := s.expertRepo.GetLastNotSolvedCaseID(expert.ID)
        if err == nil </span><span class="cov0" title="0">{
                return s.caseRepo.GetCaseByID(caseID)
        }</span>
        <span class="cov0" title="0">if !errors.Is(err, errs.ErrNoLastNotSolvedCase) </span><span class="cov0" title="0">{
                return domain.Case{}, err
        }</span>

        <span class="cov0" title="0">notSolvedCase, err := s.expertRepo.GetNotSolvedCase(expert)
        if err != nil </span><span class="cov0" title="0">{
                return domain.Case{}, err
        }</span>

        <span class="cov0" title="0">err = s.expertRepo.InsertNotSolvedCase(domain.ExpertCase{
                ExpertCaseID:  uuid.New().String(),
                ExpertID:      expert.ID,
                CaseID:        notSolvedCase.ID,
                IsExpertSolve: false,
                FineDecision:  false,
                GotAt:         time.Now(),
        })
        if err != nil </span><span class="cov0" title="0">{
                return domain.Case{}, err
        }</span>

        <span class="cov0" title="0">return notSolvedCase, err</span>
}

func (s *expertService) GetExpertByUserID(userID string) (domain.Expert, error) <span class="cov0" title="0">{
        return s.expertRepo.GetExpertByUserID(userID)
}</span>

func (s *expertService) SetCaseDecision(decision domain.Decision) (domain.CaseDecisionInfo, error) <span class="cov0" title="0">{
        decision.SolvedAt = time.Now()
        err := s.expertRepo.SetCaseDecision(decision)
        if err != nil </span><span class="cov0" title="0">{
                return domain.CaseDecisionInfo{}, err
        }</span>

        <span class="cov0" title="0">caseDecisions, err := s.expertRepo.GetCaseFineDecisions(decision.CaseID)
        if err != nil </span><span class="cov0" title="0">{
                return domain.CaseDecisionInfo{}, err
        }</span>

        <span class="cov0" title="0">if caseDecisions.PositiveDecisions &gt;= s.consensus </span><span class="cov0" title="0">{
                err = s.caseRepo.SetCaseFineDecision(decision.CaseID, true, time.Now())
                if err != nil </span><span class="cov0" title="0">{
                        return domain.CaseDecisionInfo{}, err
                }</span>
                <span class="cov0" title="0">return domain.CaseDecisionInfo{
                        CaseID:         decision.CaseID,
                        ShouldSendFine: true,
                        IsSolved:       true,
                }, err</span>
        }
        <span class="cov0" title="0">if caseDecisions.NegativeDecisions &gt;= s.consensus </span><span class="cov0" title="0">{
                err = s.caseRepo.SetCaseFineDecision(decision.CaseID, false, time.Now())
                if err != nil </span><span class="cov0" title="0">{
                        return domain.CaseDecisionInfo{}, err
                }</span>
                <span class="cov0" title="0">return domain.CaseDecisionInfo{
                        CaseID:         decision.CaseID,
                        ShouldSendFine: false,
                        IsSolved:       true,
                }, nil</span>
        }

        <span class="cov0" title="0">expertsCnt, err := s.expertRepo.GetExpertsCountBySkill(decision.Expert.CompetenceSkill)
        if err != nil </span><span class="cov0" title="0">{
                return domain.CaseDecisionInfo{}, err
        }</span>

        <span class="cov0" title="0">totalDecisions := caseDecisions.PositiveDecisions + caseDecisions.NegativeDecisions

        leftExperts := expertsCnt - totalDecisions
        leftDecisions := s.consensus - max(caseDecisions.PositiveDecisions, caseDecisions.NegativeDecisions)
        if leftExperts &lt; leftDecisions </span><span class="cov0" title="0">{
                return domain.CaseDecisionInfo{
                        CaseID:         decision.CaseID,
                        ShouldSendFine: false,
                        IsSolved:       false,
                }, s.caseRepo.UpdateCaseRequiredSkill(decision.CaseID, decision.Expert.CompetenceSkill+1)
        }</span>

        <span class="cov0" title="0">return domain.CaseDecisionInfo{
                CaseID:         decision.CaseID,
                ShouldSendFine: false,
                IsSolved:       false,
        }, nil</span>
}

func (s *expertService) GetCaseWithPersonInfo(caseID string) (domain.Case, error) <span class="cov0" title="0">{
        return s.caseRepo.GetCaseWithPersonInfo(caseID)
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">package service

import (
        "TrafficPolice/internal/errs"
        "fmt"
        "log"
        "os"
        "path/filepath"
)

type ImgService interface {
        SaveImg(img []byte, filepath string) error
        GetImgFilePath(dir string, id string) (string, error)
}

type imgServiceLocal struct {
}

func NewImgService() ImgService <span class="cov0" title="0">{
        return &amp;imgServiceLocal{}
}</span>

func (s *imgServiceLocal) SaveImg(img []byte, filepath string) error <span class="cov0" title="0">{
        imgFile, err := os.Create(filepath)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error while create file to server: %v\n", err)
                return err
        }</span>
        <span class="cov0" title="0">defer imgFile.Close()

        _, err = imgFile.Write(img)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error while writing tempFile: %v\n", err)
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *imgServiceLocal) GetImgFilePath(dir string, id string) (string, error) <span class="cov0" title="0">{
        pattern := fmt.Sprintf("%s/%s.*", dir, id)
        files, err := filepath.Glob(pattern)
        if len(files) == 0 </span><span class="cov0" title="0">{
                return "", errs.ErrNoImage
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return files[0], nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package service

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/repository"
)

type PaginationService interface {
        GetPaginationInfo(table string, paginationParams domain.PaginationParams) (domain.Pagination, error)
}

type paginationService struct {
        paginationRepo repository.PaginationRepo
}

func NewPaginationService(paginationRepo repository.PaginationRepo) PaginationService <span class="cov8" title="1">{
        return &amp;paginationService{
                paginationRepo: paginationRepo,
        }
}</span>

func (s *paginationService) GetPaginationInfo(
        table string,
        paginationParams domain.PaginationParams,
) (domain.Pagination, error) <span class="cov8" title="1">{
        recordsCount, err := s.paginationRepo.GetRecordsCount(table)
        if err != nil </span><span class="cov8" title="1">{
                return domain.Pagination{}, err
        }</span>

        <span class="cov8" title="1">var pagination domain.Pagination

        // Set current/record per page data
        pagination.CurrentPage = paginationParams.Page
        pagination.RecordPerPage = paginationParams.Limit

        totalPages := recordsCount / paginationParams.Limit
        // Calculate Total Page
        remainder := recordsCount % paginationParams.Limit
        if remainder == 0 </span><span class="cov8" title="1">{
                pagination.TotalPage = totalPages
        }</span> else<span class="cov8" title="1"> {
                pagination.TotalPage = totalPages + 1
        }</span>

        // Calculate the Next/Previous Page
        <span class="cov8" title="1">if paginationParams.Page &lt;= 0 </span><span class="cov8" title="1">{
                pagination.Next = paginationParams.Page + 1
        }</span> else<span class="cov8" title="1"> if paginationParams.Page &lt; pagination.TotalPage </span><span class="cov8" title="1">{
                pagination.Previous = paginationParams.Page - 1
                pagination.Next = paginationParams.Page + 1
        }</span> else<span class="cov8" title="1"> if paginationParams.Page == pagination.TotalPage </span><span class="cov8" title="1">{
                pagination.Previous = paginationParams.Page - 1
                pagination.Next = 0
        }</span>

        <span class="cov8" title="1">return pagination, nil</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package service

import (
        "TrafficPolice/internal/config"
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/repository"
        "log"
        "math"
        "sort"
        "time"
)

type RatingService interface {
        SetRating(caseDecision domain.CaseDecisionInfo) error
        GetRating() ([]domain.RatingInfo, error)
        RunReportPeriod(done &lt;-chan struct{})
}

type ratingService struct {
        ratingRepo repository.RatingRepo
        ratingCfg  config.RatingConfig
}

func NewRatingService(
        ratingRepo repository.RatingRepo,
        ratingCfg config.RatingConfig,
) RatingService <span class="cov0" title="0">{
        return &amp;ratingService{
                ratingRepo: ratingRepo,
                ratingCfg:  ratingCfg,
        }
}</span>

func (s *ratingService) SetRating(caseDecision domain.CaseDecisionInfo) error <span class="cov0" title="0">{
        solvedDecisions, err := s.ratingRepo.GetSolvedCaseDecisions(caseDecision)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.ratingRepo.SetRating(solvedDecisions)</span>
}

func (s *ratingService) GetRating() ([]domain.RatingInfo, error) <span class="cov0" title="0">{
        rating, err := s.ratingRepo.GetRating()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if len(rating) == 0 </span><span class="cov0" title="0">{
                return nil, errs.ErrNoRows
        }</span>

        <span class="cov0" title="0">return rating, nil</span>
}

func (s *ratingService) RunReportPeriod(done &lt;-chan struct{}) <span class="cov0" title="0">{
        log.Printf("RunReportPeriod with duration: %s\n", s.ratingCfg.ReportPeriod)
        ticker := time.NewTicker(s.ratingCfg.ReportPeriod)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        log.Println("Run report period")
                        err := s.setupCompetenceSkill()
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println(err)
                        }</span>
                case &lt;-done:<span class="cov0" title="0">
                        log.Println("DONE")
                        return</span>
                }
        }
}

func (s *ratingService) setupCompetenceSkill() error <span class="cov0" title="0">{
        ratings, err := s.ratingRepo.GetExpertsRating(s.ratingCfg.MinSolvedCases)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(ratings) &lt; s.ratingCfg.MinExperts </span><span class="cov0" title="0">{
                log.Printf("Report period: Not enough experts. Min experts: %d, but got: %d",
                        s.ratingCfg.MinExperts, len(ratings),
                )
                return nil
        }</span>

        <span class="cov0" title="0">sort.Slice(ratings, func(i, j int) bool </span><span class="cov0" title="0">{
                return (ratings[i].CorrectCnt - ratings[i].IncorrectCnt) &gt; (ratings[j].CorrectCnt - ratings[j].IncorrectCnt)
        }</span>)
        <span class="cov0" title="0">log.Println(ratings)
        tenPercent := int(math.Ceil(float64(len(ratings)) / 10))

        skills := make([]domain.UpdateCompetenceSkill, 0)

        // Get top 10%
        for i := 0; i &lt; tenPercent; i++ </span><span class="cov0" title="0">{
                s := domain.UpdateCompetenceSkill{ExpertID: ratings[i].ExpertID, ShouldIncrease: true}
                skills = append(skills, s)
        }</span>

        // Get last 10%
        <span class="cov0" title="0">for i := len(ratings) - 1; i &gt; len(ratings)-1-tenPercent; i-- </span><span class="cov0" title="0">{
                s := domain.UpdateCompetenceSkill{ExpertID: ratings[i].ExpertID, ShouldIncrease: false}
                skills = append(skills, s)
        }</span>

        <span class="cov0" title="0">err = s.ratingRepo.UpdateCompetenceSkills(skills)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return s.ratingRepo.ClearRating()</span>
}
</pre>
		
		<pre class="file" id="file46" style="display: none">package service

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/repository"
)

type TrainingService interface {
        GetSolvedCasesByParams(params domain.SolvedCasesParams, paginationParams domain.PaginationParams) ([]domain.Case, error)
}

type trainingService struct {
        trainingRepo repository.TrainingRepo
}

func NewTrainingService(trainingRepo repository.TrainingRepo) TrainingService <span class="cov0" title="0">{
        return &amp;trainingService{
                trainingRepo: trainingRepo,
        }
}</span>

func (s *trainingService) GetSolvedCasesByParams(
        params domain.SolvedCasesParams,
        paginationParams domain.PaginationParams,
) ([]domain.Case, error) <span class="cov0" title="0">{
        return s.trainingRepo.GetSolvedCasesByParams(params, paginationParams)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package service

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/repository"
        "github.com/google/uuid"
)

type ViolationService interface {
        InsertViolations(violations []*domain.Violation) error
}

type violationService struct {
        repo repository.ViolationRepo
}

func NewViolationService(db repository.ViolationRepo) ViolationService <span class="cov0" title="0">{
        return &amp;violationService{repo: db}
}</span>

func (s *violationService) InsertViolations(violations []*domain.Violation) error <span class="cov0" title="0">{
        for i := range violations </span><span class="cov0" title="0">{
                violations[i].ID = uuid.New().String()
        }</span>

        <span class="cov0" title="0">return s.repo.InsertViolations(violations)</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package tokens

import (
        "TrafficPolice/internal/domain"
        "errors"
        "fmt"
        "github.com/golang-jwt/jwt/v5"
        "math/rand"
        "time"
)

type TokenInfo struct {
        UserID   string
        UserRole domain.Role
}

type TokenManager interface {
        NewJWT(tokenInfo TokenInfo, ttl time.Duration) (string, error)
        Parse(accessToken string) (TokenInfo, error)
        NewRefreshToken() (string, error)
}

type manager struct {
        signingKey string
}

func NewTokenManager(signingKey string) (TokenManager, error) <span class="cov8" title="1">{
        if signingKey == "" </span><span class="cov8" title="1">{
                return nil, errors.New("empty signing key")
        }</span>

        <span class="cov8" title="1">return &amp;manager{signingKey: signingKey}, nil</span>
}

func (m *manager) NewJWT(tokenInfo TokenInfo, ttl time.Duration) (string, error) <span class="cov8" title="1">{
        if tokenInfo.UserID == "" || tokenInfo.UserRole == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("userID or user role is empty")
        }</span>
        <span class="cov8" title="1">token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "exp":  time.Now().Add(ttl).Unix(),
                "sub":  tokenInfo.UserID,
                "role": tokenInfo.UserRole,
        })

        return token.SignedString([]byte(m.signingKey))</span>
}

func (m *manager) Parse(accessToken string) (TokenInfo, error) <span class="cov0" title="0">{
        keyFunc := func(token *jwt.Token) (i interface{}, err error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("unexpected signing method: %v", token.Header["alg"])
                }</span>

                <span class="cov0" title="0">return []byte(m.signingKey), nil</span>
        }
        <span class="cov0" title="0">token, err := jwt.Parse(accessToken, keyFunc)
        if err != nil </span><span class="cov0" title="0">{
                return TokenInfo{}, err
        }</span>

        <span class="cov0" title="0">claims, ok := token.Claims.(jwt.MapClaims)
        if !ok </span><span class="cov0" title="0">{
                return TokenInfo{}, fmt.Errorf("error get user claims from token")
        }</span>

        <span class="cov0" title="0">return TokenInfo{
                UserID:   claims["sub"].(string),
                UserRole: domain.Role(claims["role"].(string)),
        }, nil</span>
}

func (m *manager) NewRefreshToken() (string, error) <span class="cov0" title="0">{
        b := make([]byte, 32)

        s := rand.NewSource(time.Now().Unix())
        r := rand.New(s)

        if _, err := r.Read(b); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return fmt.Sprintf("%x", b), nil</span>
}
</pre>
		
		<pre class="file" id="file49" style="display: none">package rabbitmq

import (
        "TrafficPolice/internal/config"
        "fmt"
        amqp "github.com/rabbitmq/amqp091-go"
)

func NewRabbitMQConn(cfg *config.Config) (*amqp.Connection, error) <span class="cov0" title="0">{
        url := fmt.Sprintf(
                "amqp://%s:%s@%s:%d/",
                cfg.RabbitMQ.User,
                cfg.RabbitMQ.Password,
                cfg.RabbitMQ.Host,
                cfg.RabbitMQ.Port,
        )
        return amqp.Dial(url)
}</span>
</pre>
		
		<pre class="file" id="file50" style="display: none">package rabbitmq

import (
        "TrafficPolice/internal/transport/rest/dto"
        "context"
        "encoding/json"
        amqp "github.com/rabbitmq/amqp091-go"
        "log"
        "time"
)

const (
        jsonContentType = "application/json"
        FineExchange    = "fine"
        FineQueue       = "fine_queue"
        Fanout          = "fanout"
)

type FinePublisher struct {
        amqpChan *amqp.Channel
}

func NewFinePublisher(mqConn *amqp.Connection) (*FinePublisher, error) <span class="cov0" title="0">{
        amqpChan, err := mqConn.Channel()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;FinePublisher{
                amqpChan: amqpChan,
        }, nil</span>
}

func (p *FinePublisher) SetupExchangeAndQueue(
        exchangeParams ExchangeParams,
        queueParams QueueParams,
        bindingsParams BindingParams,
) error <span class="cov0" title="0">{
        err := p.amqpChan.ExchangeDeclare(
                exchangeParams.Name,
                exchangeParams.Kind,
                exchangeParams.Durable,
                exchangeParams.AutoDelete,
                exchangeParams.Internal,
                exchangeParams.NoWait,
                exchangeParams.Args,
        )

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">_, err = p.amqpChan.QueueDeclare(
                queueParams.Name,
                queueParams.Durable,
                queueParams.AutoDelete,
                queueParams.Exclusive,
                queueParams.NoWait,
                queueParams.Args,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = p.amqpChan.QueueBind(
                bindingsParams.Queue,
                bindingsParams.Key,
                bindingsParams.Exchange,
                bindingsParams.NoWait,
                bindingsParams.Args,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (p *FinePublisher) CloseChan() <span class="cov0" title="0">{
        if err := p.amqpChan.Close(); err != nil </span><span class="cov0" title="0">{
                log.Printf("FinePublisher CloseChan: %v\n", err)
        }</span>
}

func (p *FinePublisher) Publish(exchange string, contentType string, body []byte) error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        err := p.amqpChan.PublishWithContext(
                ctx,
                exchange,
                "",
                false,
                false,
                amqp.Publishing{
                        ContentType: contentType,
                        Body:        body,
                },
        )

        return err
}</span>

func (p *FinePublisher) PublishFineNotification(c dto.CaseWithImage) error <span class="cov0" title="0">{
        cBytes, err := json.Marshal(c)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return p.Publish(FineExchange, jsonContentType, cBytes)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">package rest

import (
        "TrafficPolice/internal/converter"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/transport/rest/dto"
        "TrafficPolice/internal/transport/rest/response"
        "encoding/json"
        "errors"
        "github.com/go-playground/validator/v10"
        "log"
        "net/http"
)

type AuthHandler struct {
        service           service.AuthService
        validate          *validator.Validate
        userInfoConverter *converter.UserInfoConverter
        authConverter     *converter.AuthConverter
}

func NewAuthHandler(service service.AuthService,
        validate *validator.Validate,
        userInfoConverter *converter.UserInfoConverter,
        authConverter *converter.AuthConverter,
) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{
                service:           service,
                validate:          validate,
                userInfoConverter: userInfoConverter,
                authConverter:     authConverter,
        }
}</span>

// SignUp docs
// @Summary Регистрация эксперта
// @Tags auth
// @Description Регистрация эксперта по логину и паролю
// @ID auth-sign-up
// @Accept  json
// @Produce  json
// @Param input body dto.SignUp true "Логин и пароль"
// @Success 200 {object} response.Body
// @Failure 400,401,409 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /auth/sign_up [post]
func (h *AuthHandler) SignUp(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var input dto.SignUp

        err := json.NewDecoder(r.Body).Decode(&amp;input)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = h.validate.Struct(input)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = h.service.RegisterExpert(h.userInfoConverter.MapSignUpToUserInfo(input))
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrAlreadyExists) </span><span class="cov0" title="0">{
                        response.Conflict(w, "User with this username already exists")
                        return
                }</span>
                <span class="cov0" title="0">log.Println(err)
                response.InternalServerError(w)
                return</span>
        }
        <span class="cov0" title="0">response.OKMessage(w, "You signed up successfully")</span>
}

// SignIn docs
// @Summary Вход пользователей
// @Tags auth
// @Description Вход для всех пользователей по логину и паролю
// @ID auth-sign-in
// @Accept  json
// @Produce  json
// @Param input body dto.SignInInput true "Логин и пароль"
// @Success 200 {object} dto.SignInOutput
// @Failure 400,401,404 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /auth/sign_in [post]
func (h *AuthHandler) SignIn(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var input dto.SignInInput

        err := json.NewDecoder(r.Body).Decode(&amp;input)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = h.validate.Struct(input)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">tokens, err := h.service.SignIn(h.userInfoConverter.MapSignInToUserInfo(input))

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrNoRows) </span><span class="cov0" title="0">{
                        response.NotFound(w, "User with this username not exists")
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, errs.ErrInvalidPass) </span><span class="cov0" title="0">{
                        response.Unauthorized(w)
                        return
                }</span>
                <span class="cov0" title="0">http.Error(w, err.Error(), http.StatusInternalServerError)
                return</span>
        }

        <span class="cov0" title="0">ansBytes, err := json.Marshal(
                dto.SignInOutput{
                        AccessToken:  tokens.AccessToken,
                        RefreshToken: tokens.RefreshToken,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                response.InternalServerError(w)
                log.Println(err)
                return
        }</span>

        <span class="cov0" title="0">response.WriteResponse(w, http.StatusOK, ansBytes)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
        }</span>
}

// ConfirmExpert docs
// @Summary Подтверждение эксперта
// @Security ApiKeyAuth
// @Tags auth
// @Description Подтверждение эксперта по id. Может делать только директор
// @ID auth-confirm-expert
// @Accept  json
// @Produce  json
// @Param input body dto.ConfirmExpertInput true "id эксперта и информация о подтверждении"
// @Success 200 {object} dto.SignInOutput
// @Failure 400,401,404 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /auth/confirm/expert [post]
func (h *AuthHandler) ConfirmExpert(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var input dto.ConfirmExpertInput

        err := json.NewDecoder(r.Body).Decode(&amp;input)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = h.validate.Struct(input)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = h.service.ConfirmExpert(h.authConverter.MapConfirmExpertDtoToDomain(input))

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrNoRows) </span><span class="cov0" title="0">{
                        response.NotFound(w, "Expert with input id not found")
                        return
                }</span>
                <span class="cov0" title="0">response.InternalServerError(w)
                return</span>
        }

        <span class="cov0" title="0">if input.IsConfirmed </span><span class="cov0" title="0">{
                response.OKMessage(w, "Expert confirmed successfully")
        }</span> else<span class="cov0" title="0"> {
                response.OKMessage(w, "Expert unconfirmed successfully")
        }</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package rest

import (
        "TrafficPolice/internal/converter"
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/transport/rest/dto"
        "TrafficPolice/internal/transport/rest/response"
        "encoding/json"
        "errors"
        "github.com/go-playground/validator/v10"
        "log"
        "net/http"
)

type CameraHandler struct {
        cameraService   service.CameraService
        authService     service.AuthService
        validate        *validator.Validate
        cameraConverter *converter.CameraConverter
}

func NewCameraHandler(
        service service.CameraService,
        authService service.AuthService,
        validate *validator.Validate,
        cameraConverter *converter.CameraConverter,
) *CameraHandler <span class="cov0" title="0">{
        return &amp;CameraHandler{
                cameraService:   service,
                authService:     authService,
                validate:        validate,
                cameraConverter: cameraConverter,
        }
}</span>

// AddCameraType docs
// @Summary Регистрация вида камеры
// @Security ApiKeyAuth
// @Tags camera
// @Description Зарегистрировать новый вид камеры может только директор. Возвращает id вида камеры
// @ID create-camera-type
// @Accept  json
// @Produce  json
// @Param input body dto.CameraTypeIn true "Информация о виде камеры"
// @Success 200 {object} response.IDResponse
// @Failure 400,409 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /camera/type [post]
func (h *CameraHandler) AddCameraType(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var cameraType dto.CameraTypeIn
        err := json.NewDecoder(r.Body).Decode(&amp;cameraType)

        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = h.validate.Struct(cameraType)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">cameraTypeID, err := h.cameraService.AddCameraType(domain.CameraType{
                Name: cameraType.Name,
        })

        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrAlreadyExists) </span><span class="cov0" title="0">{
                        response.Conflict(w, "Camera with input name already exists")
                        return
                }</span>
                <span class="cov0" title="0">response.InternalServerError(w)
                return</span>
        }

        <span class="cov0" title="0">response.IdResponse(w, cameraTypeID)</span>
}

// RegisterCamera docs
// @Summary Регистрация камеры
// @Security ApiKeyAuth
// @Tags camera
// @Description Зарегистрировать камеру может только директор. Возвращает id камеры
// @ID create-camera
// @Accept  json
// @Produce  json
// @Param input body dto.RegisterCamera true "Информация о камере"
// @Success 200 {object} response.IDResponse
// @Failure 400,409 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /camera [post]
func (h *CameraHandler) RegisterCamera(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var registerInfo dto.RegisterCamera
        err := json.NewDecoder(r.Body).Decode(&amp;registerInfo)

        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = h.validate.Struct(registerInfo)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">cameraID, err := h.authService.RegisterCamera(
                h.cameraConverter.MapRegisterCameraDtoToDomain(registerInfo.CameraIn, registerInfo.SignUp),
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrAlreadyExists) </span><span class="cov0" title="0">{
                        response.Conflict(w, "Camera with this username already exists")
                        return
                }</span>
                <span class="cov0" title="0">log.Println(err)
                response.InternalServerError(w)
                return</span>
        }

        <span class="cov0" title="0">response.IdResponse(w, cameraID)</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package rest

import (
        "TrafficPolice/internal/camera"
        "TrafficPolice/internal/converter"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/transport/rest/response"
        "fmt"
        "github.com/pkg/errors"
        "io"
        "log"
        "net/http"
)

const (
        casesDir            = "cases"
        caseContentImageKey = "image"
        caseIDPathValue     = "id"
)

type CaseHandler struct {
        caseService   service.CaseService
        imgService    service.ImgService
        cameraService service.CameraService
        caseConverter *converter.CaseConverter
        cameraParser  *camera.Parser
}

func NewCaseHandler(
        service service.CaseService,
        imgService service.ImgService,
        cameraService service.CameraService,
        caseConverter *converter.CaseConverter,
        cameraParser *camera.Parser,
) *CaseHandler <span class="cov0" title="0">{

        return &amp;CaseHandler{
                caseService:   service,
                imgService:    imgService,
                cameraService: cameraService,
                caseConverter: caseConverter,
                cameraParser:  cameraParser,
        }
}</span>

// AddCase docs
// @Summary Добавление информации о проишествии
// @Security ApiKeyAuth
// @Tags case
// @Description Принимает бинарную строку в описанном формате. Добавить проишествие может только камера
// @ID case-add
// @Accept   application/octet-stream
// @Produce  json
// @Success 200 {object} response.IDResponse
// @Failure 400,401 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /case [post]
func (h *CaseHandler) AddCase(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        buf, err := io.ReadAll(r.Body)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">inputCase, err := h.cameraParser.ParseCameraInfo(buf)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrEmptyPayload) </span><span class="cov0" title="0">{
                        response.BadRequest(w, "Binary string is empty")
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, errs.ErrUnknownCameraID) </span><span class="cov0" title="0">{
                        response.BadRequest(w, "Cannot parse camera id")
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, errs.ErrUnknownCameraType) </span><span class="cov0" title="0">{
                        response.BadRequest(w, "Unknown camera type")
                        return
                }</span>
                <span class="cov0" title="0">log.Println(err)
                response.InternalServerError(w)
                return</span>
        }

        <span class="cov0" title="0">caseID, err := h.caseService.AddCase(h.caseConverter.MapDtoToDomain(inputCase))
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrNoTransport) </span><span class="cov0" title="0">{
                        response.BadRequest(w, "No transport by input credentials")
                        return
                }</span>
                <span class="cov0" title="0">log.Println(err)
                response.InternalServerError(w)
                return</span>
        }

        <span class="cov0" title="0">response.IdResponse(w, caseID)</span>
}

// UploadCaseImg docs
// @Summary Добавление фотографии к проишествию
// @Security ApiKeyAuth
// @Tags case
// @Description Принимает фотографию и сохраняет ее по переданному id. Добавить фотографию может только камера
// @ID case-image-upload
// @Accept   multipart/form-data
// @Produce  json
// @Param id query string true "id камеры"
// @Param file formData file true "Фотография проишествия"
// @Success 200 {object} response.Body
// @Failure 400,401 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /case/{id}/img [post]
func (h *CaseHandler) UploadCaseImg(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        caseID := r.PathValue(caseIDPathValue)
        if caseID == "" </span><span class="cov0" title="0">{
                response.BadRequest(w, "id is empty")
                return
        }</span>

        <span class="cov0" title="0">file, header, err := parseMultipartForm(r, caseContentImageKey)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">contentType := header.Header.Get(contentTypeKey)
        extension, err := getImgExtension(contentType)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">imgFilePath := fmt.Sprintf("%s/%s.%s", casesDir, caseID, extension)
        fileBytes, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error while reading fileBytes: %v\n", fileBytes)
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">err = h.imgService.SaveImg(fileBytes, imgFilePath)
        if err != nil </span><span class="cov0" title="0">{
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">response.OKMessage(w, "Successfully uploaded image")</span>
}

// GetCaseImg docs
// @Summary Получение фотографии проишествия
// @Security ApiKeyAuth
// @Tags case
// @Description Получение фотографии проишествия по id прошествия. Воспользоваться могут эксперт или директор
// @ID case-image-get
// @Accept   multipart/form-data
// @Produce  json
// @Param id query string true "id камеры"
// @Success 200 {file} formData
// @Failure 400,401,404 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /case/{id}/img [get]
func (h *CaseHandler) GetCaseImg(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        caseID := r.PathValue(caseIDPathValue)
        if caseID == "" </span><span class="cov0" title="0">{
                response.BadRequest(w, "bad case id")
                return
        }</span>

        <span class="cov0" title="0">file, err := h.imgService.GetImgFilePath(casesDir, caseID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrNoImage) </span><span class="cov0" title="0">{
                        response.NotFound(w, "Image with input case id not found")
                        return
                }</span>
                <span class="cov0" title="0">log.Println(err)
                response.InternalServerError(w)
                return</span>
        }

        <span class="cov0" title="0">http.ServeFile(w, r, file)</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package rest

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/transport/rest/response"
        "github.com/xuri/excelize/v2"
        "log"
        "net/http"
)

const (
        contactInfoSheet   = "Лист1"
        contactInfoFileKey = "file"
)

type ContactInfoHandler struct {
        service service.ContactInfoService
}

func NewContactInfoHandler(service service.ContactInfoService) *ContactInfoHandler <span class="cov0" title="0">{
        return &amp;ContactInfoHandler{service: service}
}</span>

// InsertContactInfo docs
// @Summary Ввод информации о транспорте и его владельце
// @Security ApiKeyAuth
// @Tags contact_info
// @Description Принимает excel файл в формате по столбикам: Буквы авто:Номера авто:Регион:Номер телефона:email:VK ID: Tg ID. Только директор может загрузить файл
// @ID insert-contact-info
// @Accept  multipart/form-data
// @Produce  json
// @Param file formData file true "Excel файл с контактной информацией"
// @Success 200 {object} response.Body
// @Failure 400,401 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /contact_info [post]
func (h *ContactInfoHandler) InsertContactInfo(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        maxMemory := int64(10 &lt;&lt; 30)

        err := r.ParseMultipartForm(maxMemory)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        // retrieve file from posted form-data
        <span class="cov0" title="0">formFile, _, err := r.FormFile(contactInfoFileKey)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>
        <span class="cov0" title="0">defer formFile.Close()

        f, err := excelize.OpenReader(formFile)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">rows, err := f.GetRows(contactInfoSheet)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">m := make(map[string][]*domain.Transport)

        for _, row := range rows </span><span class="cov0" title="0">{
                transport := &amp;domain.Transport{
                        Chars:  row[0],
                        Num:    row[1],
                        Region: row[2],
                }

                person := &amp;domain.Person{
                        PhoneNum: row[3],
                        Email:    row[4],
                        VkID:     row[5],
                        TgID:     row[6],
                }
                transport.Person = person

                if _, ok := m[person.PhoneNum]; !ok </span><span class="cov0" title="0">{
                        m[person.PhoneNum] = make([]*domain.Transport, 0)
                }</span>
                <span class="cov0" title="0">m[person.PhoneNum] = append(m[person.PhoneNum], transport)</span>
        }

        <span class="cov0" title="0">err = h.service.InsertContactInfo(m)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">response.OKMessage(w, "Contact info added successfully")</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package rest

import (
        "TrafficPolice/internal/converter"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/transport/rest/response"
        "encoding/json"
        "errors"
        "fmt"
        "log"
        "net/http"
        "time"
)

const (
        expertIDKey  = "id"
        startTimeKey = "start_time"
        endTimeKey   = "end_time"
)

type DirectorHandler struct {
        directorService    service.DirectorService
        caseConverter      *converter.CaseConverter
        analyticsConverter *converter.AnalyticsConverter
}

func NewDirectorHandler(
        directorService service.DirectorService,
        caseConverter *converter.CaseConverter,
        analyticsConverter *converter.AnalyticsConverter,
) *DirectorHandler <span class="cov0" title="0">{
        return &amp;DirectorHandler{
                directorService:    directorService,
                caseConverter:      caseConverter,
                analyticsConverter: analyticsConverter,
        }
}</span>

// GetCases docs
// @Summary Получение состояния случаев
// @Security ApiKeyAuth
// @Tags director
// @Description Получение состояния случаев. Воспользоваться может только директор
// @ID director-cases-get
// @Produce  json
// @Success 200 {object} []dto.CaseStatus
// @Success 204 ""
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /director/cases [get]
func (h *DirectorHandler) GetCases(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        cases, err := h.directorService.GetCases()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrNoRows) </span><span class="cov0" title="0">{
                        response.NoContent(w)
                        return
                }</span>
                <span class="cov0" title="0">log.Println(err)
                response.InternalServerError(w)</span>
        }

        <span class="cov0" title="0">casesBytes, err := json.Marshal(h.caseConverter.MapCaseStatusesToDto(cases))
        if err != nil </span><span class="cov0" title="0">{
                response.InternalServerError(w)
        }</span>

        <span class="cov0" title="0">response.WriteResponse(w, http.StatusOK, casesBytes)</span>
}

// ExpertAnalytics docs
// @Summary Получение аналитики проверяющих специалистов по промежуткам времени
// @Security ApiKeyAuth
// @Tags director
// @Description Получить количество всех случаев, правильно решенных случае, неправильно решенных случаев,
// неизвестных случаев и максимальное количество подряд решенных задач. Воспользоваться может только директор
// @ID director-analytics-expert
// @Produce  json
// @Param id query int true "id эксперта"
// @Param start_time query string true "Начало промежутка времени в формате yyyy-mm-dd"
// @Param end_time query string true "Конец промежутка времени в формате yyyy-mm-dd"
// @Success 200 {object} []dto.AnalyticsInterval
// @Success 204 ""
// @Failure 400,401,404 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /director/analytics/expert [get]
func (h *DirectorHandler) ExpertAnalytics(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        expertID := r.URL.Query().Get(expertIDKey)
        if expertID == "" </span><span class="cov0" title="0">{
                response.BadRequest(w, "Id is empty")
                return
        }</span>

        <span class="cov0" title="0">startTime, err := h.parseTimeQuery(r, startTimeKey)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">endTime, err := h.parseTimeQuery(r, endTimeKey)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">analytics, err := h.directorService.GetExpertAnalytics(expertID, startTime, endTime)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrExpertNotExists) </span><span class="cov0" title="0">{
                        response.NotFound(w, "Expert with input ID not found")
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, errs.ErrNoRows) </span><span class="cov0" title="0">{
                        response.NoContent(w)
                        return
                }</span>
                <span class="cov0" title="0">log.Println(err)
                response.InternalServerError(w)
                return</span>
        }

        <span class="cov0" title="0">analyticsBytes, err := json.Marshal(h.analyticsConverter.MapDomainsToDtos(analytics))
        if err != nil </span><span class="cov0" title="0">{
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">response.WriteResponse(w, http.StatusOK, analyticsBytes)</span>
}

func (h *DirectorHandler) parseTimeQuery(r *http.Request, key string) (time.Time, error) <span class="cov0" title="0">{
        timeQuery := r.URL.Query().Get(key)
        if timeQuery == "" </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("%s is empty", key)
        }</span>

        <span class="cov0" title="0">date, err := time.Parse(time.DateOnly, timeQuery)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>

        <span class="cov0" title="0">return date, nil</span>
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package rest

import (
        "TrafficPolice/internal/converter"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/tokens"
        "TrafficPolice/internal/transport/rabbitmq"
        "TrafficPolice/internal/transport/rest/dto"
        "TrafficPolice/internal/transport/rest/middlewares"
        "TrafficPolice/internal/transport/rest/response"
        "encoding/json"
        "errors"
        "fmt"
        "io"
        "log"
        "net/http"
        "os"
        "strings"
)

const (
        expertsDir            = "experts"
        expertContentImageKey = "image"
        expertIDPathValue     = "id"
)

type ExpertHandler struct {
        imgService            service.ImgService
        expertService         service.ExpertService
        ratingService         service.RatingService
        finePublisher         *rabbitmq.FinePublisher
        caseConverter         *converter.CaseConverter
        caseDecisionConverter *converter.CaseDecisionConverter
}

func NewExpertHandler(
        imgService service.ImgService,
        expertService service.ExpertService,
        ratingService service.RatingService,
        finePublisher *rabbitmq.FinePublisher,
        caseConverter *converter.CaseConverter,
        caseDecisionConverter *converter.CaseDecisionConverter,
) *ExpertHandler <span class="cov0" title="0">{
        return &amp;ExpertHandler{
                imgService:            imgService,
                expertService:         expertService,
                ratingService:         ratingService,
                finePublisher:         finePublisher,
                caseConverter:         caseConverter,
                caseDecisionConverter: caseDecisionConverter,
        }
}</span>

// UploadExpertImg docs
// @Summary Добавление фотографии к профилю эксперта
// @Security ApiKeyAuth
// @Tags expert
// @Description Добавление фотографии к профилю эксперта. Может воспользоваться директор или эксперт
// @ID expert-image-upload
// @Accept   multipart/form-data
// @Produce  json
// @Param id query string true "id эксперта"
// @Param file formData file true "Фотография эксперта"
// @Success 200 {object} response.Body
// @Failure 400,401 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /expert/{id}/img [post]
func (h *ExpertHandler) UploadExpertImg(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        expertID := r.PathValue(expertIDPathValue)
        if expertID == "" </span><span class="cov0" title="0">{
                response.BadRequest(w, "Bad expert id")
                return
        }</span>

        <span class="cov0" title="0">file, header, err := parseMultipartForm(r, expertContentImageKey)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">contentType := header.Header.Get(contentTypeKey)
        extension, err := getImgExtension(contentType)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">imgFilePath := fmt.Sprintf("%s/%s.%s", expertsDir, expertID, extension)
        fileBytes, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error while reading fileBytes: %v\n", fileBytes)
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">err = h.imgService.SaveImg(fileBytes, imgFilePath)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">response.OKMessage(w, "Successfully uploaded image")</span>
}

// GetExpertImg docs
// @Summary Получение фотографии эксперта
// @Security ApiKeyAuth
// @Tags expert
// @Description Получение фотографии эксперта по его id. Воспользоваться могут эксперт или директор
// @ID expert-image-get
// @Accept   multipart/form-data
// @Produce  json
// @Param id query string true "id эксперта"
// @Success 200 {file} formData
// @Failure 400,401,404 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /expert/{id}/img [get]
func (h *ExpertHandler) GetExpertImg(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        expertID := r.PathValue(expertIDPathValue)
        if expertID == "" </span><span class="cov0" title="0">{
                response.BadRequest(w, "Bad expert id")
                return
        }</span>

        <span class="cov0" title="0">file, err := h.imgService.GetImgFilePath(expertsDir, expertID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrNoImage) </span><span class="cov0" title="0">{
                        response.NotFound(w, "Image with input expert id not found")
                        return
                }</span>
                <span class="cov0" title="0">log.Println(err)
                response.InternalServerError(w)
                return</span>
        }

        <span class="cov0" title="0">http.ServeFile(w, r, file)</span>
}

// GetCaseForExpert docs
// @Summary Получение случая для оценки экспертом
// @Security ApiKeyAuth
// @Tags expert
// @Description Получение случая для оценки экспертом. Воспользоваться могут эксперт или директор
// @ID expert-get-case
// @Produce  json
// @Success 200 {file} dto.Case
// @Success 204 ""
// @Failure 401,404 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /expert/get_case [get]
func (h *ExpertHandler) GetCaseForExpert(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tokenInfo := r.Context().Value(middlewares.TokenInfoKey).(tokens.TokenInfo)

        c, err := h.expertService.GetCase(tokenInfo.UserID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrUserNotExists) </span><span class="cov0" title="0">{
                        response.NotFound(w, "Expert not found")
                }</span>
                <span class="cov0" title="0">if errors.Is(err, errs.ErrNoNotSolvedCase) || errors.Is(err, errs.ErrNoCase) </span><span class="cov0" title="0">{
                        response.NoContent(w)
                        return
                }</span>
                <span class="cov0" title="0">log.Println(err)
                response.InternalServerError(w)
                return</span>
        }

        <span class="cov0" title="0">cBytes, err := json.Marshal(h.caseConverter.MapDomainToDto(c))
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">response.WriteResponse(w, http.StatusOK, cBytes)</span>
}

// SetCaseDecision docs
// @Summary Оценка случая экспертом
// @Security ApiKeyAuth
// @Tags expert
// @Description Установка оценки случая экспертом. Воспользоваться может только эксперт
// @ID expert-set-decision
// @Accept   json
// @Produce  json
// @Param input body dto.Decision true "id случая и решение эксперта"
// @Success 200 {file} response.Body
// @Failure 400,401,404 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /expert/decision [post]
func (h *ExpertHandler) SetCaseDecision(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tokenInfo := r.Context().Value(middlewares.TokenInfoKey).(tokens.TokenInfo)

        var decision dto.Decision
        err := json.NewDecoder(r.Body).Decode(&amp;decision)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">expert, err := h.expertService.GetExpertByUserID(tokenInfo.UserID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrUserNotExists) </span><span class="cov0" title="0">{
                        response.NotFound(w, "Input expert not found")
                        return
                }</span>
                <span class="cov0" title="0">log.Println(err)
                response.InternalServerError(w)
                return</span>
        }

        <span class="cov0" title="0">caseDecision, err := h.expertService.SetCaseDecision(
                h.caseDecisionConverter.MapDtoToDomain(decision, expert),
        )

        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">if caseDecision.IsSolved </span><span class="cov0" title="0">{
                err = h.ratingService.SetRating(caseDecision)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        response.InternalServerError(w)
                }</span>
        }

        <span class="cov0" title="0">if caseDecision.ShouldSendFine </span><span class="cov0" title="0">{
                caseInfo, err := h.expertService.GetCaseWithPersonInfo(decision.CaseID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        return
                }</span>
                <span class="cov0" title="0">c := h.caseConverter.MapCaseWithPersonToDTO(caseInfo)
                image, extension, err := h.getCaseImage(caseInfo.ID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        return
                }</span>
                <span class="cov0" title="0">err = h.finePublisher.PublishFineNotification(dto.CaseWithImage{
                        Case:           c,
                        Image:          image,
                        ImageExtension: extension,
                })
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        return
                }</span>
        }

        <span class="cov0" title="0">response.OKMessage(w, "Decision accepted")</span>
}

func (h *ExpertHandler) getCaseImage(caseID string) ([]byte, string, error) <span class="cov0" title="0">{
        file, err := h.imgService.GetImgFilePath(casesDir, caseID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">img, err := os.ReadFile(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", err
        }</span>

        <span class="cov0" title="0">dotIdx := strings.LastIndex(file, ".")
        return img, file[dotIdx+1:], nil</span>
}
</pre>
		
		<pre class="file" id="file57" style="display: none">package middlewares

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/tokens"
        "TrafficPolice/internal/transport/rest/response"
        "context"
        "errors"
        "log"
        "net/http"
        "strings"
)

type ContextKey int

const (
        authorizationHeader string     = "Authorization"
        TokenInfoKey        ContextKey = 1
)

type AuthMiddleware struct {
        tokenManager  tokens.TokenManager
        expertService service.ExpertService
}

func NewAuthMiddleware(tokenManager tokens.TokenManager, expertService service.ExpertService) *AuthMiddleware <span class="cov0" title="0">{
        return &amp;AuthMiddleware{
                tokenManager:  tokenManager,
                expertService: expertService,
        }
}</span>

func (h *AuthMiddleware) IdentifyRole(next http.Handler, roles ...domain.Role) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                authHeader := r.Header.Get(authorizationHeader)
                tokenInfo, err := h.parseAuthHeader(authHeader)

                if err != nil </span><span class="cov0" title="0">{
                        response.Unauthorized(w)
                        return
                }</span>

                <span class="cov0" title="0">hasPermission := false
                for _, role := range roles </span><span class="cov0" title="0">{
                        if tokenInfo.UserRole == role </span><span class="cov0" title="0">{
                                hasPermission = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if !hasPermission </span><span class="cov0" title="0">{
                        response.Unauthorized(w)
                        return
                }</span>

                <span class="cov0" title="0">ctx := context.WithValue(r.Context(), TokenInfoKey, tokenInfo)
                next.ServeHTTP(w, r.WithContext(ctx))</span>
        })
}

func (h *AuthMiddleware) IsExpertConfirmed(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                authHeader := r.Header.Get(authorizationHeader)
                tokenInfo, err := h.parseAuthHeader(authHeader)

                if err != nil </span><span class="cov0" title="0">{
                        response.Unauthorized(w)
                        return
                }</span>

                <span class="cov0" title="0">if tokenInfo.UserRole != domain.ExpertRole </span><span class="cov0" title="0">{
                        next.ServeHTTP(w, r)
                        return
                }</span>

                <span class="cov0" title="0">expert, err := h.expertService.GetExpertByUserID(tokenInfo.UserID)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println(err)
                        response.Unauthorized(w)
                        return
                }</span>
                <span class="cov0" title="0">if !expert.IsConfirmed </span><span class="cov0" title="0">{
                        response.NotConfirmedError(w)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}

func (h *AuthMiddleware) parseAuthHeader(authHeader string) (tokens.TokenInfo, error) <span class="cov0" title="0">{
        if authHeader == "" </span><span class="cov0" title="0">{
                return tokens.TokenInfo{}, errors.New("empty auth header")
        }</span>

        <span class="cov0" title="0">headerParts := strings.Split(authHeader, " ")
        if len(headerParts) != 2 || headerParts[0] != "Bearer" </span><span class="cov0" title="0">{
                return tokens.TokenInfo{}, errors.New("invalid auth header")
        }</span>

        <span class="cov0" title="0">if len(headerParts[1]) == 0 </span><span class="cov0" title="0">{
                return tokens.TokenInfo{}, errors.New("token is empty")
        }</span>
        <span class="cov0" title="0">accessToken := headerParts[1]

        return h.tokenManager.Parse(accessToken)</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">package rest

import (
        "fmt"
        "log"
        "mime/multipart"
        "net/http"
        "strings"
)

var allowedExtensions = map[string]struct{}{
        "png":  {},
        "jpeg": {},
        "jpg":  {},
}

const (
        contentTypeKey = "Content-Type"
        contentImage   = "image"
)

func parseMultipartForm(r *http.Request, key string) (multipart.File, *multipart.FileHeader, error) <span class="cov0" title="0">{
        // parse input, type multipart/form-data
        // 10 MB
        maxMemory := int64(10 &lt;&lt; 20)

        err := r.ParseMultipartForm(maxMemory)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Error while ParseMultipartForm: %v", err)
                return nil, nil, err
        }</span>

        // retrieve file from posted form-data
        <span class="cov0" title="0">file, header, err := r.FormFile(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("Error retrieving file from form-data: %v\n", err)
        }</span>

        <span class="cov0" title="0">return file, header, nil</span>
}

func getImgExtension(contentType string) (string, error) <span class="cov0" title="0">{
        slashIdx := strings.Index(contentType, "/")
        if slashIdx == -1 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("bad content type")
        }</span>

        <span class="cov0" title="0">fileType := contentType[:slashIdx]
        extension := contentType[slashIdx+1:]

        if fileType != contentImage </span><span class="cov0" title="0">{
                return "", fmt.Errorf("file type %s is not image", fileType)
        }</span>

        <span class="cov0" title="0">_, isAllowed := allowedExtensions[extension]
        if isAllowed </span><span class="cov0" title="0">{
                return extension, nil
        }</span> else<span class="cov0" title="0"> {
                return "", fmt.Errorf("extension %s is not allowed", extension)
        }</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">package rest

import (
        "TrafficPolice/internal/converter"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/transport/rest/response"
        "encoding/json"
        "errors"
        "log"
        "net/http"
)

type RatingHandler struct {
        ratingService   service.RatingService
        ratingConverter converter.RatingConverter
}

func NewRatingHandler(
        ratingService service.RatingService,
        ratingConverter *converter.RatingConverter,
) *RatingHandler <span class="cov0" title="0">{
        return &amp;RatingHandler{
                ratingService:   ratingService,
                ratingConverter: *ratingConverter,
        }
}</span>

// GetRating docs
// @Summary Получение рейтинга экспертов
// @Security ApiKeyAuth
// @Tags rating
// @Description Получение рейтинга экспертов. Воспользоваться могут эксперт или директор
// @ID rating-get
// @Produce  json
// @Success 200 {object} []dto.RatingInfo
// @Success 204 ""
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /rating [get]
func (h *RatingHandler) GetRating(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        rating, err := h.ratingService.GetRating()
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrNoRows) </span><span class="cov0" title="0">{
                        response.NoContent(w)
                        return
                }</span>
                <span class="cov0" title="0">log.Println(err)
                response.InternalServerError(w)</span>
        }

        <span class="cov0" title="0">ratingBytes, err := json.Marshal(h.ratingConverter.MapSliceDomainToDto(rating))
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                response.InternalServerError(w)
        }</span>

        <span class="cov0" title="0">response.WriteResponse(w, http.StatusOK, ratingBytes)</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package response

import (
        "encoding/json"
        "log"
        "net/http"
)

type Body struct {
        Message string `json:"message"`
}

type IDResponse struct {
        ID string `json:"id"`
}

func WriteResponse(w http.ResponseWriter, status int, body []byte) <span class="cov0" title="0">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        _, err := w.Write(body)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("error occurred when write body msg: %v", body)
                return
        }</span>
}

func WriteMessage(w http.ResponseWriter, status int, msg string) <span class="cov0" title="0">{
        respBody := Body{Message: msg}
        body, err := json.Marshal(respBody)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                log.Printf("error occurred when marshalling response body: %v\n", respBody)
                return
        }</span>

        <span class="cov0" title="0">WriteResponse(w, status, body)</span>
}

func BadRequest(w http.ResponseWriter, text string) <span class="cov0" title="0">{
        WriteMessage(w, http.StatusBadRequest, text)
}</span>

func NotFound(w http.ResponseWriter, text string) <span class="cov0" title="0">{
        WriteMessage(w, http.StatusNotFound, text)
}</span>

func OKMessage(w http.ResponseWriter, text string) <span class="cov0" title="0">{
        WriteMessage(w, http.StatusOK, text)
}</span>

func NoContent(w http.ResponseWriter) <span class="cov0" title="0">{
        w.WriteHeader(http.StatusNoContent)
}</span>

func Conflict(w http.ResponseWriter, text string) <span class="cov0" title="0">{
        WriteMessage(w, http.StatusConflict, text)
}</span>

func InternalServerError(w http.ResponseWriter) <span class="cov0" title="0">{
        WriteMessage(w, http.StatusInternalServerError, "Internal server error")
}</span>

func Unauthorized(w http.ResponseWriter) <span class="cov0" title="0">{
        w.Header().Set("WWW-Authenticate", `Basic realm="restricted", charset="UTF-8"`)
        WriteMessage(w, http.StatusUnauthorized, "Unauthorized")
}</span>

func IdResponse(w http.ResponseWriter, id string) <span class="cov0" title="0">{
        respBody := IDResponse{ID: id}
        body, err := json.Marshal(respBody)
        if err != nil </span><span class="cov0" title="0">{
                w.WriteHeader(http.StatusInternalServerError)
                log.Printf("error occurred when marshalling response body: %v\n", respBody)
                return
        }</span>

        <span class="cov0" title="0">WriteResponse(w, http.StatusOK, body)</span>
}

func NotConfirmedError(w http.ResponseWriter) <span class="cov0" title="0">{
        WriteMessage(w, http.StatusForbidden, "You are not confirmed")
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">package rest

import (
        "TrafficPolice/internal/converter"
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/errs"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/transport/rest/dto"
        "TrafficPolice/internal/transport/rest/response"
        "encoding/json"
        "errors"
        "github.com/go-playground/validator/v10"
        "log"
        "net/http"
        "strconv"
)

const (
        defaultPage    = 1
        defaultLimit   = 10
        pageKey        = "page"
        limitKey       = "limit"
        casesTableName = "cases"
)

type TrainingHandler struct {
        trainingService      service.TrainingService
        paginationService    service.PaginationService
        validate             *validator.Validate
        caseConverter        *converter.CaseConverter
        paginationConverter  *converter.PaginationConverter
        solvedCasesConverter *converter.SolvedCasesConverter
}

func NewTrainingHandler(
        trainingService service.TrainingService,
        paginationService service.PaginationService,
        validate *validator.Validate,
        caseConverter *converter.CaseConverter,
        paginationConverter *converter.PaginationConverter,
        solvedCasesConverter *converter.SolvedCasesConverter,
) *TrainingHandler <span class="cov0" title="0">{
        return &amp;TrainingHandler{
                trainingService:      trainingService,
                paginationService:    paginationService,
                validate:             validate,
                caseConverter:        caseConverter,
                paginationConverter:  paginationConverter,
                solvedCasesConverter: solvedCasesConverter,
        }
}</span>

// GetSolvedCasesByParams docs
// @Summary Получение проишествий для тренировки
// @Security ApiKeyAuth
// @Tags expert
// @Description Получение прошествий для тренировки. Может воспользоваться только эксперт
// @ID expert-training
// @Accept  json
// @Produce  json
// @Param input body dto.SolvedCasesParams true "Информация для фильтров по проишествиям"
// @Param page query int true "номер страницы"
// @Param limit query int true "Лимит кейсов на странице"
// @Success 200 {object} dto.TrainingInfo
// @Failure 400,404 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /expert/training [post]
func (h *TrainingHandler) GetSolvedCasesByParams(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        page, err := h.parseQueryParam(r, pageKey, defaultPage)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">limit, err := h.parseQueryParam(r, limitKey, defaultLimit)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">var params dto.SolvedCasesParams

        err = json.NewDecoder(r.Body).Decode(&amp;params)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">err = h.validate.Struct(params)
        if err != nil </span><span class="cov0" title="0">{
                response.BadRequest(w, err.Error())
                return
        }</span>

        <span class="cov0" title="0">paginationParams := domain.PaginationParams{
                Page:  page,
                Limit: limit,
        }

        cases, err := h.trainingService.GetSolvedCasesByParams(
                h.solvedCasesConverter.MapParamsDtoToDomain(params),
                paginationParams,
        )
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, errs.ErrNoRows) </span><span class="cov0" title="0">{
                        response.NotFound(w, "Cases with input params are not found")
                        return
                }</span>
                <span class="cov0" title="0">log.Println(err)
                response.InternalServerError(w)
                return</span>
        }

        <span class="cov0" title="0">pagination, err := h.paginationService.GetPaginationInfo(casesTableName, paginationParams)
        if err != nil </span><span class="cov0" title="0">{
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">trainingInfo := dto.TrainingInfo{
                Cases:      h.caseConverter.MapDomainsToDto(cases),
                Pagination: h.paginationConverter.MapDomainToDto(pagination),
        }

        infoBody, err := json.Marshal(trainingInfo)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">response.WriteResponse(w, http.StatusOK, infoBody)</span>
}

func (h *TrainingHandler) parseQueryParam(r *http.Request, key string, defaultValue int) (int, error) <span class="cov0" title="0">{
        queryParam := r.URL.Query().Get(key)

        if queryParam == "" </span><span class="cov0" title="0">{
                return defaultValue, nil
        }</span>

        <span class="cov0" title="0">param, err := strconv.Atoi(queryParam)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">if param == 0 </span><span class="cov0" title="0">{
                return defaultValue, nil
        }</span>
        <span class="cov0" title="0">return param, nil</span>

}
</pre>
		
		<pre class="file" id="file62" style="display: none">package rest

import (
        "TrafficPolice/internal/domain"
        "TrafficPolice/internal/service"
        "TrafficPolice/internal/transport/rest/response"
        "fmt"
        "github.com/xuri/excelize/v2"
        "log"
        "net/http"
        "strconv"
)

const (
        violationSheet   = "Лист1"
        violationFileKey = "file"
)

type ViolationHandler struct {
        service service.ViolationService
}

func NewViolationHandler(service service.ViolationService) *ViolationHandler <span class="cov0" title="0">{
        return &amp;ViolationHandler{service: service}
}</span>

// InsertViolations docs
// @Summary Ввод информации о правонарушениях
// @Security ApiKeyAuth
// @Tags violation
// @Description Принимает excel файл в формате по столбикам: Название правонарушения:Размер штрафа. Только директор может загрузить файл
// @ID insert-violations
// @Accept  multipart/form-data
// @Produce  json
// @Param file formData file true "Excel файл с информацией о правонарушениях"
// @Success 200 {object} response.Body
// @Failure 400,401 {object} response.Body
// @Failure 500 {object} response.Body
// @Failure default {object} response.Body
// @Router /violations [post]
func (h *ViolationHandler) InsertViolations(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        maxMemory := int64(10 &lt;&lt; 30)

        err := r.ParseMultipartForm(maxMemory)
        if err != nil </span><span class="cov0" title="0">{
                text := fmt.Sprintf("Error while ParseMultipartForm: %v", err)
                response.BadRequest(w, text)
                return
        }</span>

        // retrieve file from posted form-data
        <span class="cov0" title="0">formFile, _, err := r.FormFile(violationFileKey)
        if err != nil </span><span class="cov0" title="0">{
                text := fmt.Sprintf("Error retrieving file from form-data: %v\n", err)
                response.BadRequest(w, text)
                return
        }</span>
        <span class="cov0" title="0">defer formFile.Close()

        f, err := excelize.OpenReader(formFile)
        if err != nil </span><span class="cov0" title="0">{
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">rows, err := f.GetRows(violationSheet)
        if err != nil </span><span class="cov0" title="0">{
                log.Println(err)
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">violations := h.parseViolations(rows)

        err = h.service.InsertViolations(violations)
        if err != nil </span><span class="cov0" title="0">{
                response.InternalServerError(w)
                return
        }</span>

        <span class="cov0" title="0">response.OKMessage(w, "Violations added successfully")</span>
}

func (h *ViolationHandler) parseViolations(rows [][]string) []*domain.Violation <span class="cov0" title="0">{
        violations := make([]*domain.Violation, 0)

        for _, row := range rows </span><span class="cov0" title="0">{
                isValid := true
                for _, val := range row </span><span class="cov0" title="0">{
                        if val == "" </span><span class="cov0" title="0">{
                                isValid = false
                        }</span>
                        <span class="cov0" title="0">break</span>
                }
                <span class="cov0" title="0">if !isValid </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fineAmount, err := strconv.Atoi(row[1])
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">v := &amp;domain.Violation{
                        Name:       row[0],
                        FineAmount: fineAmount,
                }

                violations = append(violations, v)</span>
        }

        <span class="cov0" title="0">return violations</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package validation

import (
        "github.com/go-playground/validator/v10"
        "log"
        "time"
)

func IsDateOnly(fl validator.FieldLevel) bool <span class="cov0" title="0">{
        _, err := time.Parse(time.DateOnly, fl.Field().String())
        log.Println(fl.Field().String())
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file64" style="display: none">package hash

import (
        "crypto/sha1"
        "fmt"
)

type PasswordHasher interface {
        Hash(password string) (string, error)
}

// SHA1Hasher uses SHA1 to hash passwords with provided salt.
type SHA1Hasher struct {
        salt string
}

func NewSHA1Hasher(salt string) *SHA1Hasher <span class="cov8" title="1">{
        return &amp;SHA1Hasher{salt: salt}
}</span>

// Hash creates SHA1 hash of given password.
func (h *SHA1Hasher) Hash(password string) (string, error) <span class="cov8" title="1">{
        hash := sha1.New()

        if _, err := hash.Write([]byte(password)); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%x", hash.Sum([]byte(h.salt))), nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
